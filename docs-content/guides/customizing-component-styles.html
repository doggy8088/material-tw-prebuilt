<div class="docs-markdown"><h1 id="customizing-angular-material-component-styles" translation-result="on">自定義 Angular Material 元件樣式</h1><h1 translation-origin="off">Customizing Angular Material component styles</h1><p translation-result="on">Angular Material 支援透過 Sass API 自定義元件樣式，如<a href="https://material.angular.cn/guide/theming">主題指南</a>中所述。本文件提供了一個指南，用於指導如何定義自定義 CSS 規則，以便直接設定 Angular Material 元件的樣式。</p><p translation-origin="off">Angular Material supports customizing component styles via Sass API as described in the <a href="https://material.angular.io/guide/theming">theming
guide</a>. This document provides guidance on defining custom CSS rules that directly style
Angular Material components.</p>


        <h2 id="targeting-custom-styles" class="docs-header-link" translation-result="on">
          <span header-link="定位自定義樣式"></span>
          定位自定義樣式
        </h2><h2 class="docs-header-link" translation-origin="off">
          <span header-link="targeting-custom-styles"></span>
          Targeting custom styles
        </h2>
      
        
      
        <h3 id="component-host-elements" class="docs-header-link" translation-result="on">
          <span header-link="元件的宿主元素"></span>
          元件的宿主元素
        </h3><h3 class="docs-header-link" translation-origin="off">
          <span header-link="component-host-elements"></span>
          Component host elements
        </h3>
      
        
      <p translation-result="on">對於任何 Angular Material 元件，你可以安全地為元件的宿主元素自定義 CSS，以便影響元件的位置或佈局，例如 <code>margin</code>、<code>position</code>、<code>top</code>、<code>left</code>、<code>transform</code> 和 <code>z-index</code>。你應該透過自定義 CSS 類並將該類別應用於元件的宿主元素來應用這個類。</p><p translation-origin="off">For any Angular Material component, you can safely define custom CSS for a component's host element
that affect the positioning or layout of that component, such as <code>margin</code>, <code>position</code>, <code>top</code>,
<code>left</code>, <code>transform</code>, and <code>z-index</code>. You should apply such styles by defining a custom CSS
class and applying that class to the component's host element.</p>

<p translation-result="on">要避免定義會影響元件大小或內部佈局的自定義樣式，例如 <code>padding</code>、<code>height</code>、<code>width</code> 或 <code>overflow</code>。你可以指定 <code>display: none</code> 來隱藏元件，但儘量不要指定任何其他 <code>display</code> 值。當其內部樣式在發行版之間發生變化時，覆蓋這些屬性可能會以意想不到的方式破壞元件。</p><p translation-origin="off">Avoid defining custom styles that would affect the size or internal layout of the component, such as
<code>padding</code>, <code>height</code>, <code>width</code>, or <code>overflow</code>. You can specify <code>display: none</code> to hide a component,
but avoid specifying any other <code>display</code> value. Overriding these properties can break components
in unexpected ways as the internal styles change between releases.</p>


        <h3 id="internal-component-elements" class="docs-header-link" translation-result="on">
          <span header-link="元件的內部元素"></span>
          元件的內部元素
        </h3><h3 class="docs-header-link" translation-origin="off">
          <span header-link="internal-component-elements"></span>
          Internal component elements
        </h3>
      
        
      <p translation-result="on">避免在 Angular Material 元件中的內部元素上使用任何自定義樣式或進行 CSS 覆蓋。各個元件的 DOM 結構和 CSS 類都可能隨時更改，從而導致這些自定義樣式被破壞。</p><p translation-origin="off">Avoid any custom styles or overrides on internal elements within a Angular Material components.
The DOM structure and CSS classes applied for each component may change at any time, causing custom
styles to break.</p>


        <h2 id="applying-styles-to-angular-material-components" class="docs-header-link" translation-result="on">
          <span header-link="將樣式應用於-angular-material-元件"></span>
          將樣式應用於 Angular Material 元件
        </h2><h2 class="docs-header-link" translation-origin="off">
          <span header-link="applying-styles-to-angular-material-components"></span>
          Applying styles to Angular Material components
        </h2>
      
        
      <p translation-result="on">雖然 Angular Material 不支援在元件的內部元素上定義自定義樣式或進行 CSS 覆蓋，但是你仍然可以選擇這樣做。自定義 Angular Material 元件的樣式時，需要考慮三點：檢視封裝、CSS 特異度和渲染位置。</p><p translation-origin="off">While Angular Material does not support defining custom styles or CSS overrides on components'
internal elements, you might choose to do this anyway. There are three points to consider while
customizing styles for Angular Material components: view encapsulation, CSS specificity, and
rendering location.</p>


        <h3 id="view-encapsulation" class="docs-header-link" translation-result="on">
          <span header-link="檢視封裝"></span>
          檢視封裝
        </h3><h3 class="docs-header-link" translation-origin="off">
          <span header-link="view-encapsulation"></span>
          View encapsulation
        </h3>
      
        
      <p translation-result="on">預設情況下，Angular 範圍化元件的樣式只會影響該組件的檢視本身。也就是說你寫的任何樣式都只會影響到你這個元件樣板中的直屬元素。 封裝過的樣式<strong>不會</strong>影響到你樣板中用到的其它元件的任何子元素。你可以到 <a href="https://angular.cn/guide/component-styles#view-encapsulation">Angular 官方文件</a>中瞭解關於檢視封裝的更多知識。還可以到 Angular 官方部落格中讀一下 <a href="https://blog.angular.cn/the-state-of-css-in-angular-4a52d4bd2700"><em>Angular 中 CSS 的狀態</em></a>。</p><p translation-origin="off">By default, Angular scopes component styles to exclusively affect that component's view. This means
that the styles you author affect only the elements directly within your component template.
Encapsulated styles do <em>not</em> affect elements that are children of other components within your
template. You can read more about view encapsulation in the
<a href="https://angular.io/guide/component-styles#view-encapsulation">Angular documentation</a>. You may
also wish to review
<a href="https://blog.angular.io/the-state-of-css-in-angular-4a52d4bd2700"><em>The State of CSS in Angular</em></a>
on the Angular blog.</p>


        <h4 id="bypassing-encapsulation" class="docs-header-link" translation-result="on">
          <span header-link="繞過封裝"></span>
          繞過封裝
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="bypassing-encapsulation"></span>
          Bypassing encapsulation
        </h4>
      
        
      <p translation-result="on">Angular Material 停用了庫中所有元件的樣式封裝。但是，在你自己的元件中使用預設的樣式封裝方式仍然可以防止自定義樣式洩漏到 Angular Material 元件中。</p><p translation-origin="off">Angular Material disables style encapsulation for all components in the library. However, the
default style encapsulation in your own components still prevents custom styles from leaking into
Angular Material components.</p>

<p translation-result="on">如果你的元件啟用了檢視封裝，那麼它的樣式只會影響到樣板中顯式定義的元素。要影響樣板中使用的元件的後代，可以使用以下方法之一：</p><p translation-origin="off">If your component enables view encapsulation, your component styles will only
affect the elements explicitly defined in your template. To affect descendants of components used
in your template, you can use one of the following approaches:</p>

<ol>
<li><p translation-result="on">在 <code>angular.json</code> 設定檔案的 <code>styles</code> 陣列中宣告的全域樣式表中自定義樣式。</p><p translation-origin="off">Define custom styles in a global stylesheet declared in the <code>styles</code> array of your <code>angular.json</code>
configuration file.</p>

</li>
<li><p translation-result="on">停用元件的檢視封裝。這種方法可以有效地將你的元件樣式轉換為全域 CSS。</p><p translation-origin="off">Disable view encapsulation for your component. This approach effectively turns your component
styles into global CSS.</p>

</li>
<li><p translation-result="on">將已棄用的 <code>::ng-deep</code> 偽類應用於 CSS 規則。 任何 <code>::ng-deep</code> CSS 規則都將成為全域樣式。請參閱 Angular 文件以獲取有關 <a href="https://angular.io/guide/component-styles#deprecated-deep--and-ng-deep"><code>::ng-deep</code></a> 的更多訊息。</p><p translation-origin="off">Apply the deprecated <code>::ng-deep</code> pseudo-class to a CSS rule. Any CSS rule with <code>::ng-deep</code>
becomes a global style. <a href="https://angular.io/guide/component-styles#deprecated-deep--and-ng-deep">See the Angular documentation for more on <code>::ng-deep</code></a>.</p>

</li>
</ol>
<p translation-result="on">所有這些方法都可以建立不受樣式封裝影響的全域 CSS。這些全域 CSS 會影響應用程式中的所有元素。其類別名稱可能與元件中定義的類別名稱衝突。全域 CSS 容易導致難以診斷的錯誤，並且通常很難維護。</p><p translation-origin="off">All of these approaches involve creating global CSS that isn't affected by style encapsulation.
Global CSS affects all elements in your application. Global CSS class names may collide with class
names defined by components. Global CSS is often a source of hard-to-diagnose bugs and is generally
difficult to maintain.</p>


        <h3 id="css-specificity" class="docs-header-link" translation-result="on">
          <span header-link="css-特異度"></span>
          CSS 特異度
        </h3><h3 class="docs-header-link" translation-origin="off">
          <span header-link="css-specificity"></span>
          CSS specificity
        </h3>
      
        
      <p translation-result="on">每個 CSS 宣告都具有一個<em>特異度</em>級別，取決於所用到的選擇器的型別和數量。特異度較高的樣式也會有較高的優先級。Angular Material 自己會在元件中使用儘可能小的特異度。不過，Angular Material 將來也可能更改元件樣式的特異度，這可能會讓你的自定義覆蓋規則變得脆弱、容易被破壞。</p><p translation-origin="off">Each CSS declaration has a level of <em>specificity</em> based on the type and number of selectors used.
More specific styles take precedence over less specific styles. Angular Material generally attempts
to use the least specific selectors possible. However, Angular Material may change component style
specificity at any time, making custom overrides brittle and prone to breaking.</p>

<p translation-result="on">你可以到 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity">MDN Web 文件</a>中深入瞭解特異度及其計算方法。</p><p translation-origin="off">You can read more about specificity and how it is calculated on the
<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity">MDN web docs</a>.</p>


        <h3 id="rendering-location" class="docs-header-link" translation-result="on">
          <span header-link="渲染位置"></span>
          渲染位置
        </h3><h3 class="docs-header-link" translation-origin="off">
          <span header-link="rendering-location"></span>
          Rendering location
        </h3>
      
        
      <p translation-result="on">某些 Angular Material 元件所渲染的元素不是該組件的宿主元素的直接 DOM 後代。特別是，基於浮層的元件（例如 <code>MatDialog</code>、<code>MatMenu</code>、<code>MatTooltip</code> 等）會直接渲染到 body 上的浮層容器元素中。因為這些元件會在應用程式的元件之外渲染元素，所以特定於元件的樣式不適用於這些元素。你可以將這些元素的樣式定義為全域樣式。</p><p translation-origin="off">Some Angular Material components render elements that are not direct DOM descendants of the
component's host element. In particular, overlay-based components such as <code>MatDialog</code>, <code>MatMenu</code>,
<code>MatTooltip</code>, etc. render into an overlay container element directly on the document body. Because
these components render elements outside of your application's components, component-specific styles
will not apply to these elements. You can define styles for these elements as global styles.</p>


        <h4 id="styling-overlay-components" class="docs-header-link" translation-result="on">
          <span header-link="為浮層元件設定樣式"></span>
          為浮層元件設定樣式
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="styling-overlay-components"></span>
          Styling overlay components
        </h4>
      
        
      <p translation-result="on">基於浮層的元件具有一個 <code>panelClass</code> 屬性或類似屬性，可用於定位浮層面板。下面的範例示範了如何為 <code>MatDialog</code> 新增 <code>outline</code> 樣式。</p><p translation-origin="off">Overlay-based components have a <code>panelClass</code> property, or similar, that let you target the
overlay pane. The following example shows how to add an <code>outline</code> style with <code>MatDialog</code>.</p>

<pre><code class="language-scss"><span class="hljs-comment">// Add this to your global stylesheet after including theme mixins.</span>
<span class="hljs-selector-class">.my-outlined-dialog</span> {
  <span class="hljs-attribute">outline</span>: <span class="hljs-number">2px</span> solid purple;
}
</code></pre>
<pre><code class="language-ts"><span class="hljs-built_in">this</span>.dialog.open(MyDialogComponent, {<span class="hljs-attr">panelClass</span>: <span class="hljs-string">'my-outlined-dialog'</span>})
</code></pre>
<p translation-result="on">你應該始終將應用程式特有的字首應用於全域 CSS 類，以避免命名衝突。</p><p translation-origin="off">You should always apply an application-specific prefix to global CSS classes to avoid naming
collisions.</p>

</div>