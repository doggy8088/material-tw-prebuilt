<div class="docs-markdown"><p translation-result="on">這個 <code>scrolling</code> 套件為那些要對捲動事件做出反應的指令提供了輔助設施。</p><p translation-origin="off">The <code>scrolling</code> package provides helpers for directives that react to scroll events.</p>


        <h3 id="cdkscrollable-and-scrolldispatcher" class="docs-header-link" translation-result="on">
          <span header-link="cdkscrollable（可捲動的）-和-scrolldispatcher（捲動派發器）"></span>
          cdkScrollable（可捲動的） 和 ScrollDispatcher（捲動派發器）
        </h3><h3 class="docs-header-link" translation-origin="off">
          <span header-link="cdkscrollable-and-scrolldispatcher"></span>
          cdkScrollable and ScrollDispatcher
        </h3>
      
        
      <p translation-result="on"><code>cdkScrollable</code> 指令和 <code>ScrollDispatcher</code> 服務一起讓元件能對其任意上級捲動容器中的捲動事件做出反應。</p><p translation-origin="off">The <code>cdkScrollable</code> directive and the <code>ScrollDispatcher</code> service together allow components to
react to scrolling in any of its ancestor scrolling containers.</p>

<p translation-result="on">要把 <code>cdkScrollable</code> 指令應用在任何充當捲動容器的元素上。這會把該元素標記為 <code>Scrollable</code> 並把它註冊到 <code>ScrollDispatcher</code> 中。這時派發器允許元件分享這些事件監聽器和應用中所有可捲動容器的知識。</p><p translation-origin="off">The <code>cdkScrollable</code> directive should be applied to any element that acts as a scrolling container.
This marks the element as a <code>Scrollable</code> and registers it with the <code>ScrollDispatcher</code>. The
dispatcher, then, allows components to share both event listeners and knowledge of all of the
scrollable containers in the application.</p>


        <h3 id="viewportruler" class="docs-header-link" translation-result="on">
          <span header-link="viewportruler（視口標尺）"></span>
          ViewportRuler（視口標尺）
        </h3><h3 class="docs-header-link" translation-origin="off">
          <span header-link="viewportruler"></span>
          ViewportRuler
        </h3>
      
        
      <p translation-result="on"><code>ViewportRuler</code> 是一種可注入的服務，用於衡量瀏覽器視口的範圍。</p><p translation-origin="off">The <code>ViewportRuler</code> is a service that can be injected and used to measure the bounds of the browser
viewport.</p>


        <h3 id="virtual-scrolling" class="docs-header-link" translation-result="on">
          <span header-link="虛擬捲動"></span>
          虛擬捲動
        </h3><h3 class="docs-header-link" translation-origin="off">
          <span header-link="virtual-scrolling"></span>
          Virtual scrolling
        </h3>
      
        
      <p translation-result="on"><code>&lt;cdk-virtual-scroll-viewport&gt;</code> 透過僅僅渲染那些螢幕上可見的條目，來高效的顯示大型清單。在任何瀏覽器中載入數百個元素都會很慢，虛擬捲動可以用一種高效的方式模擬渲染全部條目，方法是讓容器元素的高度與要渲染的元素的總高度相同，然後才渲染檢視中的條目。虛擬捲動不同於無限捲動這樣的策略，它會渲染一定數量的元素，然後在你點選兩端時渲染剩下的元素。</p><p translation-origin="off">The <code>&lt;cdk-virtual-scroll-viewport&gt;</code> displays large lists of elements performantly by only
rendering the items that fit on-screen. Loading hundreds of elements can be slow in any browser;
virtual scrolling enables a performant way to simulate all items being rendered by making the
height of the container element the same as the height of total number of elements to be rendered,
and then only rendering the items in view. Virtual scrolling is different from strategies like
infinite scroll where it renders a set amount of elements and then when you hit the end renders the
rest.</p>


        <h4 id="creating-items-in-the-viewport" class="docs-header-link" translation-result="on">
          <span header-link="在視口中建立條目"></span>
          在視口中建立條目
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="creating-items-in-the-viewport"></span>
          Creating items in the viewport
        </h4>
      
        
      <p translation-result="on"><code>*cdkVirtualFor</code> 替換了 <code>&lt;cdk-virtual-scroll-viewport&gt;</code> 中的 <a href="https://angular.cn/api/common/NgForOf"><code>*ngFor</code></a>，它支援與 <a href="https://angular.cn/api/common/NgForOf"><code>*ngFor</code></a> 完全相同的 API。最簡單的用法就是指定條目清單（注意，必須在視口中設定 <code>itemSize</code> 屬性）：</p><p translation-origin="off"><code>*cdkVirtualFor</code> replaces <code>*ngFor</code> inside of a <code>&lt;cdk-virtual-scroll-viewport&gt;</code>, supporting the exact
same API as <a href="https://angular.io/api/common/NgForOf"><code>*ngFor</code></a>. The simplest usage just specifies the
list of items (note that the <code>itemSize</code> property on the viewport must be set):</p>

<div material-docs-example="cdk-virtual-scroll-overview"></div>

<p translation-result="on"><code>*cdkVirtualFor</code> 讓樣板中可以使用這些上下文變數：</p><p translation-origin="off"><code>*cdkVirtualFor</code> makes the following context variables available to the template:</p>

<table>
<thead>
<tr>
<th><nt-wrapper translation-result="on">上下文變數</nt-wrapper><nt-wrapper translation-origin="off">Context variable</nt-wrapper></th>
<th><nt-wrapper translation-result="on">說明</nt-wrapper><nt-wrapper translation-origin="off">Description</nt-wrapper></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>index</code></td>
<td><nt-wrapper translation-result="on">該條目在資料來源中的索引。</nt-wrapper><nt-wrapper translation-origin="off">The index of the item in the data source.</nt-wrapper></td>
</tr>

<tr>
<td><code>count</code></td>
<td><nt-wrapper translation-result="on">資料來源中的條目總數。</nt-wrapper><nt-wrapper translation-origin="off">The total number of items in the data source.</nt-wrapper></td>
</tr>

<tr>
<td><code>first</code></td>
<td><nt-wrapper translation-result="on">這是否是資料來源中的第一個條目。</nt-wrapper><nt-wrapper translation-origin="off">Whether this is the first item in the data source.</nt-wrapper></td>
</tr>

<tr>
<td><code>last</code></td>
<td><nt-wrapper translation-result="on">這是否是資料來源中的最後一個條目。</nt-wrapper><nt-wrapper translation-origin="off">Whether this is the last item in the data source.</nt-wrapper></td>
</tr>

<tr>
<td><code>even</code></td>
<td><nt-wrapper translation-result="on">該 <code>index</code> 是否為偶數。</nt-wrapper><nt-wrapper translation-origin="off">Whether the <code>index</code> is even.</nt-wrapper></td>
</tr>

<tr>
<td><code>odd</code></td>
<td><nt-wrapper translation-result="on">該 <code>index</code> 是否為奇數。</nt-wrapper><nt-wrapper translation-origin="off">Whether the <code>index</code> is odd.</nt-wrapper></td>
</tr>

</tbody></table>
<p translation-result="on">所有這些都是本條目在資料來源中的索引，而不是在要渲染的那部分資料的索引。</p><p translation-origin="off">All of these apply to the index of the item in the data source, not the index in the rendered
portion of the data.</p>

<div material-docs-example="cdk-virtual-scroll-context"></div>

<p translation-result="on">像 <code>*ngFor</code> 的 <code>trackBy</code> 一樣，這裡也可以指定 <code>trackBy</code> 函式，工作方式也都一樣。傳給這個 <code>trackBy</code> 的 <code>index</code> 是在資料來源中的索引，而不是在要渲染的這部分資料中的索引。</p><p translation-origin="off">A <code>trackBy</code> function can be specified and works the same as the <code>*ngFor</code> <code>trackBy</code>. The <code>index</code>
passed to the tracking function will be the index in the data source, not the index in the rendered
portion.</p>


        <h5 id="view-recycling" class="docs-header-link" translation-result="on">
          <span header-link="檢視回收"></span>
          檢視回收
        </h5><h5 class="docs-header-link" translation-origin="off">
          <span header-link="view-recycling"></span>
          View recycling
        </h5>
      
        
      <p translation-result="on">為了提高渲染效能，<code>*cdkVirtualFor</code> 會快取那些曾經建立過但不再需要的檢視。當要建立一個新檢視時，會轉而複用一個已快取的檢視。可以透過 <code>templateCacheSize</code> 屬性來調整檢視快取的大小。把這個大小設定為 <code>0</code> 會停用快取。如果你的樣板在記憶體方面很昂貴，你可能會希望減小這個數字，以免在樣板快取上花費太多記憶體。</p><p translation-origin="off">To improve rendering performance, <code>*cdkVirtualFor</code> caches previously created views after
they are no longer needed. When a new view would normally be created, a cached view
is reused instead. The size of the view cache can be adjusted via the <code>templateCacheSize</code>
property; setting this size to <code>0</code> disables caching. If your templates are expensive in terms of
memory you may wish to reduce this number to avoid spending too much memory on the template cache.</p>

<div material-docs-example="cdk-virtual-scroll-template-cache"></div>


        <h5 id="specifying-data" class="docs-header-link" translation-result="on">
          <span header-link="指定資料"></span>
          指定資料
        </h5><h5 class="docs-header-link" translation-origin="off">
          <span header-link="specifying-data"></span>
          Specifying data
        </h5>
      
        
      <p translation-result="on"><code>*cdkVirtualFor</code> 接受來自 <code>Array</code>、<code>Observable&lt;Array&gt;</code> 或 <code>DataSource</code> 的資料。虛擬捲動的 <code>DataSource</code> 與表格和樹元件所用的 <code>DataSource</code> 是同一個。<code>DataSource</code> 只是一個抽象類別，它有兩個方法：<code>connect</code> 和 <code>disconnect</code>。虛擬捲動視口將呼叫這個 <code>connect</code> 方法，以接收一個流，這個流會發出要渲染的資料陣列。當 viewport 被銷燬時，視口會呼叫 <code>disconnect</code>，這可能是清理連線過程中註冊進來的所有訂閱的最佳時機。</p><p translation-origin="off"><code>*cdkVirtualFor</code> accepts data from an <code>Array</code>, <code>Observable&lt;Array&gt;</code>, or <code>DataSource</code>. The
<code>DataSource</code> for the virtual scroll is the same one used by the table and tree components. A
<code>DataSource</code> is simply an abstract class that has two methods: <code>connect</code> and <code>disconnect</code>. The
<code>connect</code> method will be called by the virtual scroll viewport to receive a stream that emits the
data array that should be rendered. The viewport will call <code>disconnect</code> when the viewport is
destroyed, which may be the right time to clean up any subscriptions that were registered during the
connect process.</p>

<div material-docs-example="cdk-virtual-scroll-data-source"></div>


        <h4 id="scrolling-over-fixed-size-items" class="docs-header-link" translation-result="on">
          <span header-link="捲動那些固定大小的條目"></span>
          捲動那些固定大小的條目
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="scrolling-over-fixed-size-items"></span>
          Scrolling over fixed size items
        </h4>
      
        
      <p translation-result="on">當所有條目都是固定大小時，你可以使用 <code>FixedSizeVirtualScrollStrategy</code>。可以用 <code>itemSize</code> 指令輕鬆地將它新增到視口中。這種約束的優點是它可以提供更好的效能，因為在渲染條目時不需要進行測量。</p><p translation-origin="off">When all items are the same fixed size, you can use the <code>FixedSizeVirtualScrollStrategy</code>. This can
be easily added to your viewport using the <code>itemSize</code> directive. The advantage of this constraint is
that it allows for better performance, since items do not need to be measured as they are rendered. </p>

<p translation-result="on">固定大小的策略也支援設定一些緩衝區引數，用來決定渲染多少額外內容，也就是視口可見內容之外的部分。第一個引數是 <code>minBufferPx</code>。<code>minBufferPx</code> 是視口必須渲染的最小內容緩衝區數量（以畫素為單位）。如果視口檢測到要緩衝的內容小於這個數量（未填滿），就會立即渲染更多內容。第二個引數是 <code>maxBufferPx</code>。它會告訴視口當檢測到需要更多緩衝區的時候要渲染多少個備用緩衝區空間。</p><p translation-origin="off">The fixed size strategy also supports setting a couple of buffer parameters that determine how much
extra content is rendered beyond what is visible in the viewport. The first of these parameters is
<code>minBufferPx</code>. The <code>minBufferPx</code> is the minimum amount of content buffer (in pixels) that the
viewport must render. If the viewport ever detects that there is less buffered content it will
immediately render more. The second buffer parameter is <code>maxBufferPx</code>. This tells the viewport how 
much buffer space to render back up to when it detects that more buffer is required.</p>

<p translation-result="on">這兩個緩衝區引數的作用可以用一個例子來說明。假設我們有以下引數：<code>itemSize = 50</code>、<code>minBufferPx = 100</code>、<code>maxBufferPx = 250</code>。當用戶捲動瀏覽內容時，視口就會檢測到只剩下 <code>90px</code> 的緩衝區。由於它小於 <code>minBufferPx</code>，所以視口必須渲染更多緩衝區。它必須渲染足夠數量的緩衝區，直到其大於等於 <code>maxBufferPx</code>。在這種情況下，它渲染了 4 個條目（額外的 <code>200px</code>），使緩衝區總大小達到 <code>290px</code>，略高於 <code>maxBufferPx</code>。</p><p translation-origin="off">The interaction of these two buffer parameters can be best illustrated with an example. Supposed 
that we have the following parameters: <code>itemSize = 50</code>, <code>minBufferPx = 100</code>, <code>maxBufferPx = 250</code>. As
the user is scrolling through the content the viewport detects that there is only <code>90px</code> of buffer
remaining. Since this is below <code>minBufferPx</code> the viewport must render more buffer. It must render at
least enough buffer to get back to <code>maxBufferPx</code>. In this case, it renders 4 items (an additional
<code>200px</code>) to bring the total buffer size to <code>290px</code>, back above <code>maxBufferPx</code>.</p>

<div material-docs-example="cdk-virtual-scroll-fixed-buffer"></div>

<p translation-result="on">其他虛擬捲動策略可以透過擴充套件 <code>VirtualScrollStrategy</code> 來實現。目前正在 <code>@angular/cdk-experimental</code> 開發一種適用於不同大小元素的自動調整策略，但還沒有準備好用於生產環境。</p><p translation-origin="off">Other virtual scrolling strategies can be implemented by extending <code>VirtualScrollStrategy</code>. An
autosize strategy that works on elements of differing sizes is currently being developed in
<code>@angular/cdk-experimental</code>, but it is not ready for production use yet. </p>


        <h3 id="viewport-orientation" class="docs-header-link" translation-result="on">
          <span header-link="視口方向"></span>
          視口方向
        </h3><h3 class="docs-header-link" translation-origin="off">
          <span header-link="viewport-orientation"></span>
          Viewport orientation
        </h3>
      
        
      <p translation-result="on">虛擬捲動視口預設為垂直方向，也可以設定為 <code>orientation="horizontal"</code>。在改變方向時，要確保該條目是用 CSS 進行水平佈局的。要做到這一點，你可能希望把 <code>.cdk-virtual-scroll-content-wrapper</code> 類作為 CSS 的目標，它是包含待渲染內容的包裝元素。</p><p translation-origin="off">The virtual-scroll viewport defaults to a vertical orientation, but can also be set to
<code>orientation="horizontal"</code>. When changing the orientation, ensure that the item are laid
out horizontally via CSS. To do this you may want to target CSS at
<code>.cdk-virtual-scroll-content-wrapper</code> which is the wrapper element that contains the rendered
content.</p>

<div material-docs-example="cdk-virtual-scroll-horizontal"></div>


        <h3 id="elements-with-parent-tag-requirements" class="docs-header-link" translation-result="on">
          <span header-link="那些對父標籤有特定要求的元素"></span>
          那些對父標籤有特定要求的元素
        </h3><h3 class="docs-header-link" translation-origin="off">
          <span header-link="elements-with-parent-tag-requirements"></span>
          Elements with parent tag requirements
        </h3>
      
        
      <p translation-result="on">某些 HTML 元素（如 <code>&lt;tr&gt;</code> 和 <code>&lt;li&gt;</code>）對它們所在的父元素種類有一些限制。要想對這些型別的元素進行虛擬捲動操作，就要把它們放在合適的父元素中，然後把它們共同包裝在 <code>cdk-virtual-scroll-viewport</code> 中。注意，父元件中不要引入額外的空白區（比如透過 <code>margin</code> 或 <code>padding</code>），因為這樣會干擾捲動。</p><p translation-origin="off">Some HTML elements such as <code>&lt;tr&gt;</code> and <code>&lt;li&gt;</code> have limitations on the kinds of parent elements they
can be placed inside. To enable virtual scrolling over these type of elements, place the elements in
their proper parent, and then wrap the whole thing in a <code>cdk-virtual-scroll-viewport</code>. Be careful
that the parent does not introduce additional space (e.g. via <code>margin</code> or <code>padding</code>) as it will
interfere with the scrolling.</p>

<div material-docs-example="cdk-virtual-scroll-dl"></div>


        <h3 id="scrolling-strategies" class="docs-header-link" translation-result="on">
          <span header-link="捲動策略"></span>
          捲動策略
        </h3><h3 class="docs-header-link" translation-origin="off">
          <span header-link="scrolling-strategies"></span>
          Scrolling strategies
        </h3>
      
        
      <p translation-result="on">為了確定整個內容的大小以及它在任何時刻需要實際渲染的內容，視口依賴於所提供的一個 <code>VirtualScrollStrategy</code>。提供它的最簡單方式是在視口上使用 <code>itemSize</code> 指令（例如 <code>&lt;cdk-virtual-scroll-viewport itemSize="50"&gt;</code>）。但是，也可以透過建立一個實現 <code>VirtualScrollStrategy</code> 介面的類來提供自定義策略，並在包含此視口的元件上把它提供為 <code>VIRTUAL_SCROLL_STRATEGY</code>。</p><p translation-origin="off">In order to determine how large the overall content is and what portion of it actually needs to be
rendered at any given time the viewport relies on a <code>VirtualScrollStrategy</code> being provided. The
simplest way to provide it is to use the <code>itemSize</code> directive on the viewport
(e.g. <code>&lt;cdk-virtual-scroll-viewport itemSize="50"&gt;</code>). However it is also possible to provide a 
custom strategy by creating a class that implements the <code>VirtualScrollStrategy</code> interface and
providing it as the <code>VIRTUAL_SCROLL_STRATEGY</code> on the component containing your viewport.</p>

<div material-docs-example="cdk-virtual-scroll-custom-strategy"></div>


        <h3 id="append-only-mode" class="docs-header-link" translation-result="on">
          <span header-link="僅追加模式"></span>
          僅追加模式
        </h3><h3 class="docs-header-link" translation-origin="off">
          <span header-link="append-only-mode"></span>
          Append only mode
        </h3>
      
        
      <p translation-result="on">渲染非平凡條目的虛擬捲動視口可能會發現，在使用者捲動時簡單地附加到清單而用不刪除已渲染的檢視會更高效。 <code>appendOnly</code> 輸入確保已渲染的檢視在捲動出檢視後仍保留在 DOM 中。</p><p translation-origin="off">Virtual scroll viewports that render nontrivial items may find it more performant to simply append
to the list as the user scrolls without removing rendered views. The <code>appendOnly</code> input ensures
views that are already rendered persist in the DOM after they scroll out of view.</p>

<div material-docs-example="cdk-virtual-scroll-append-only"></div>


        <h3 id="separate-viewport-and-scrolling-element" class="docs-header-link" translation-result="on">
          <span header-link="單獨的視口和捲動元素"></span>
          單獨的視口和捲動元素
        </h3><h3 class="docs-header-link" translation-origin="off">
          <span header-link="separate-viewport-and-scrolling-element"></span>
          Separate viewport and scrolling element
        </h3>
      
        
      <p translation-result="on">預設情況下，虛擬捲動視口本身就會充當捲動元素。但是，在某些情況下，你可能希望讓此視口捲動其父元素之一。例如，如果你想要一些非虛擬化內容，使用者可以在虛擬化內容之前或之後捲動瀏覽。</p><p translation-origin="off">The virtual scroll viewport itself acts as the scrolling element by default. However, there may be
some cases where you want to have the viewport scroll one of its parent elements. For example,
if you want to have some non-virtualized content that the user can scroll through before or after
the virtualized content.</p>

<p translation-result="on">要將 <code>cdk-vritual-scroll-viewport</code> 設定為使用其父元素之一作為捲動元素，請把 <code>cdkVirtualScrollingElement</code> 應用於那個父元素。</p><p translation-origin="off">To configure a <code>cdk-virtual-scroll-viewport</code> to use one of its parent elements as the scrolling
element, apply <code>cdkVirtualScrollingElement</code> to the scrolling parent element.</p>

<div material-docs-example="cdk-virtual-scroll-parent-scrolling"></div>

<p translation-result="on">另一個常見的場景是使用 <code>window</code> 本身作為捲動元素。這通常是行動裝置上更好的使用者體驗，因為它允許瀏覽器 Chrome 地址欄捲動出去。要將 <code>window</code> 用作捲動元素，請將 <code>scrollWindow</code> 屬性新增到 <code>cdk-virtual-scroll-viewport</code> 。</p><p translation-origin="off">Another common scenario is using the window itself as the scrolling element. This often a better
user experience on mobile devices, as it allows the browser chrome to scroll away. To use the
window as the scrolling element, add the <code>scrollWindow</code> attribute to the 
<code>cdk-virtual-scroll-viewport</code>.</p>

<div material-docs-example="cdk-virtual-scroll-window-scrolling"></div>
</div>