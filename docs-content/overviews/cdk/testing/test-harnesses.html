<div class="docs-markdown"><p translation-result="on"><code>@angular/cdk/testing</code> 提供了一些幫助測試 Angular 元件的基礎設施。</p><p translation-origin="off"><code>@angular/cdk/testing</code> provides infrastructure to help with testing Angular components.</p>


        <h3 id="component-test-harnesses" class="docs-header-link" translation-result="on">
          <span header-link="元件測試工具"></span>
          元件測試工具
        </h3><h3 class="docs-header-link" translation-origin="off">
          <span header-link="component-test-harnesses"></span>
          Component test harnesses
        </h3>
      
        
      <p translation-result="on">元件測試工具類是一個讓測試可以透過其支援的 API 與元件互動的類。每個工具的 API 都會以和使用者相同的方式與一個元件進行互動。透過使用測試工具 API，測試可以防止對元件內部的更新，比如改變它的 DOM 結構。元件測試工具的思想來自常用於整合測試的<a href="https://martinfowler.com/bliki/PageObject.html"> PageObject </a>模式。</p><p translation-origin="off">A component harness is a class that lets a test interact with a component via a supported API.
Each harness's API interacts with a component the same way a user would. By using the harness API,
a test insulates itself against updates to the internals of a component, such as changing its DOM
structure. The idea for component harnesses comes from the
<a href="https://martinfowler.com/bliki/PageObject.html">PageObject</a> pattern commonly used for integration
testing.</p>

<p translation-result="on"><code>@angular/cdk/testing</code> 包含用於建立和使用元件測試工具的基礎設施。你可以為任何元件建立測試工具，範圍從很小的可複用元件到完整的應用頁面。</p><p translation-origin="off"><code>@angular/cdk/testing</code> contains infrastructure for creating and using component test harnesses. You
can create test harnesses for any component, ranging from small reusable widgets to full application
pages.</p>

<p translation-result="on">元件工具體系支援多種測試環境。你可以在單元測試和端到端測試中使用相同的工具實現。這意味著使用者只需要學習一個 API，而元件作者不需要維護單獨的單元測試和端到端測試實現。</p><p translation-origin="off">The component harness system supports multiple testing environments. You can use the same harness
implementation in both unit and end-to-end tests. This means that users only need to learn one API,
and component authors don't have to maintain separate unit and end-to-end test implementations.</p>

<p translation-result="on">特別是對於通用元件庫，由於其元件的廣泛使用，更容易從這種基礎設施中受益。提供一個測試工具可以讓元件的使用者編寫一些不用依賴任何私有實現細節的測試。透過在一個地方捕獲這些實現細節，消費者可以更輕鬆地更新到函式庫的最新版本。</p><p translation-origin="off">Common component libraries, in particular, benefit from this infrastructure due to the wide use of
their components. Providing a test harness allows the consumers of a component to write tests that
avoid dependencies on any private implementation details. By capturing these implementation details
in a single place, consumers can more easily update to new library versions.</p>

<p translation-result="on">本文件為三類開發人員提供了指導：</p><p translation-origin="off">This document provides guidance for three types of developers:</p>

<ol>
<li><p translation-result="on"><a href="#api-for-test-authors">測試的作者</a></p><p translation-origin="off"><a href="#api-for-test-authors">Test authors</a></p>

</li>
<li><p translation-result="on"><a href="#api-for-component-harness-authors">元件測試工具的作者</a></p><p translation-origin="off"><a href="#api-for-component-harness-authors">Component harness authors</a></p>

</li>
<li><p translation-result="on"><a href="#api-for-harness-environment-authors">測試工具環境的作者</a></p><p translation-origin="off"><a href="#api-for-harness-environment-authors">Harness environment authors</a></p>

</li>
</ol>
<p translation-result="on">由於許多開發人員只會屬於這些類別之一，因此相關的 API 會在下面按開發人員型別細分成不同章節。</p><p translation-origin="off">Since many developers fall into only one of these categories, the relevant APIs are broken out by
developer type in the sections below.</p>


        <h3 id="api-for-test-authors" class="docs-header-link" translation-result="on">
          <span header-link="給測試作者的-api"></span>
          給測試作者的 API
        </h3><h3 class="docs-header-link" translation-origin="off">
          <span header-link="api-for-test-authors"></span>
          API for test authors
        </h3>
      
        
      <p translation-result="on">測試作者就是開發人員，他們使用別人編寫的元件測試工具來測試自己的應用。例如，這可能是一個使用第三方選單元件的應用開發者，需要在單元測試中與該選單進行互動。</p><p translation-origin="off">Test authors are developers using component harnesses written by someone else to test their
application. For example, this could be an app developer who uses a third-party menu component and
needs to interact with the menu in a unit test.</p>


        <h4 id="working-with-componentharness-classes" class="docs-header-link" translation-result="on">
          <span header-link="使用-componentharness-類"></span>
          使用 <code>ComponentHarness</code> 類
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="working-with-componentharness-classes"></span>
          Working with <code>ComponentHarness</code> classes
        </h4>
      
        
      <p translation-result="on"><code>ComponentHarness</code> 是所有元件測試工具的抽象基底類別。每個測試工具都會擴充套件這個類。
所有 <code>ComponentHarness</code> 的子類別都有一個靜態屬性 <code>hostSelector</code>，它把測試工具類與 DOM 中元件的實例相對應。
除此之外，任何特定測試工具的 API 都是專屬於其對應元件的。請參閱該組件的文件，瞭解如何使用特定的測試工具。</p><p translation-origin="off"><code>ComponentHarness</code> is the abstract base class for all component harnesses. Every harness extends
this class. All <code>ComponentHarness</code> subclasses have a static property, <code>hostSelector</code>, that
matches the harness class to instances of the component in the DOM. Beyond that, the API of any
given harness is specific to its corresponding component; refer to the component's documentation to
learn how to use a specific harness.</p>


        <h4 id="using-testbedharnessenvironment-and-seleniumwebdriverharnessenvironment" class="docs-header-link" translation-result="on">
          <span header-link="使用-testbedharnessenvironment-和-seleniumwebdriverharnessenvironment"></span>
          使用 <code>TestbedHarnessEnvironment</code> 和 <code>SeleniumWebDriverHarnessEnvironment</code>
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="using-testbedharnessenvironment-and-seleniumwebdriverharnessenvironment"></span>
          Using <code>TestbedHarnessEnvironment</code> and <code>SeleniumWebDriverHarnessEnvironment</code>
        </h4>
      
        
      <p translation-result="on">這些類對應於元件工具體系的不同實現，並繫結到特定的測試環境。任何一種測試都只能匯入<em>其中一個</em>類。
基於 Karma 的單元測試應該使用 <code>TestbedHarnessEnvironment</code>，而基於 Protractor 的端到端測試應該使用 <code>SeleniumWebDriverHarnessEnvironment</code>。
其他環境會要求自定義繫結；給參見<a href="#api-for-harness-environment-authors">測試工具環境作者的 API</a>，以瞭解有關備用測試環境的更多訊息。</p><p translation-origin="off">These classes correspond to different implementations of the component harness system with bindings
for specific test environments. Any given test must only import <em>one</em> of these classes. Karma-based
unit tests should use the <code>TestbedHarnessEnvironment</code>, while Selenium WebDriver-based end-to-end tests
should use the <code>SeleniumWebDriverHarnessEnvironment</code>. Additional environments require custom bindings; see
<a href="#api-for-harness-environment-authors">API for harness environment authors</a> for more information on
alternate test environments.</p>

<p translation-result="on">這些類主要用於建立一個 <code>HarnessLoader</code> 實例，在某些情況下，還可以用來建立 <code>ComponentHarness</code> 實例。</p><p translation-origin="off">These classes are primarily used to create a <code>HarnessLoader</code> instance, and in certain cases, to
create <code>ComponentHarness</code> instances directly.</p>

<p translation-result="on"><code>TestbedHarnessEnvironment</code> 提供了以下靜態方法：</p><p translation-origin="off"><code>TestbedHarnessEnvironment</code> offers the following static methods:</p>

<table>
<thead>
<tr>
<th><nt-wrapper translation-result="on">方法</nt-wrapper><nt-wrapper translation-origin="off">Method</nt-wrapper></th>
<th><nt-wrapper translation-result="on">說明</nt-wrapper><nt-wrapper translation-origin="off">Description</nt-wrapper></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>loader(fixture: ComponentFixture&lt;unknown&gt;): HarnessLoader</code></td>
<td><nt-wrapper translation-result="on">獲取 <code>HarnessLoader</code> 實例，該實例以測試夾具的根元素為根。用來為夾具裡面的元素建立測試工具</nt-wrapper><nt-wrapper translation-origin="off">Gets a <code>HarnessLoader</code> instance for the given fixture, rooted at the fixture's root element. Should be used to create harnesses for elements contained inside the fixture</nt-wrapper></td>
</tr>

<tr>
<td><code>documentRootLoader(fixture: ComponentFixture&lt;unknown&gt;): HarnessLoader</code></td>
<td><nt-wrapper translation-result="on">獲取 <code>HarnessLoader</code> 實例，該實例以 HTML 文件的根元素為根。可以用來為那些夾具外面的元素建立測試工具</nt-wrapper><nt-wrapper translation-origin="off">Gets a <code>HarnessLoader</code> instance for the given fixture, rooted at the HTML document's root element. Can be used to create harnesses for elements that fall outside of the fixture</nt-wrapper></td>
</tr>

<tr>
<td><code>harnessForFixture&lt;T extends ComponentHarness&gt;(fixture: ComponentFixture&lt;unknown&gt;, harnessType: ComponentHarnessConstructor&lt;T&gt;): Promise&lt;T&gt;</code></td>
<td><nt-wrapper translation-result="on">用來直接為夾具的根元素建立一個 <code>ComponentHarness</code>。當使用你計劃為其載入測試工具的元件啟動測試時，這是必要的，因為在建立夾具時，Angular 還沒有設定正確的標籤名。</nt-wrapper><nt-wrapper translation-origin="off">Used to create a <code>ComponentHarness</code> instance for the fixture's root element directly. This is necessary when bootstrapping the test with the component you plan to load a harness for, because Angular does not set the proper tag name when creating the fixture.</nt-wrapper></td>
</tr>

</tbody></table>
<p translation-result="on">在大多數情況下，你可以使用 <code>TestbedHarnessEnvironment.loader(fixture)</code> 在 <code>beforeEach</code> 中建立一個 <code>HarnessLoader</code>，然後使用該 <code>HarnessLoader</code> 來建立任何必要的 <code>ComponentHarness</code> 實例。其他方法涵蓋了那些特例，如下例所示：</p><p translation-origin="off">In most cases, you can create a <code>HarnessLoader</code> in the <code>beforeEach</code> block using
<code>TestbedHarnessEnvironment.loader(fixture)</code> and then use that <code>HarnessLoader</code> to create any
necessary <code>ComponentHarness</code> instances. The other methods cover special cases as shown in this
example:</p>

<p translation-result="on">考慮一個可複用的對話框按鈕元件，它在單擊時會開啟一個對話框，其中包含以下元件，每個元件都帶有相應的工具：</p><p translation-origin="off">Consider a reusable dialog-button component that opens a dialog on click, containing the following
components, each with a corresponding harness:</p>

<ul>
<li><p translation-result="on"><code>MyDialogButton</code>（用便利 API 組合 <code>MyButton</code> 與 <code>MyDialog</code>）</p><p translation-origin="off"><code>MyDialogButton</code> (composes the <code>MyButton</code> and <code>MyDialog</code> with a convenient API)</p>

</li>
<li><p translation-result="on"><code>MyButton</code> （簡單按鈕元件）</p><p translation-origin="off"><code>MyButton</code> (a simple button component)</p>

</li>
<li><p translation-result="on"><code>MyDialog</code> （透過點選 <code>MyDialogButton</code>，把一個對話框附著到 <code>document.body</code> 上）</p><p translation-origin="off"><code>MyDialog</code> (a dialog appended to <code>document.body</code> by <code>MyDialogButton</code> upon click)</p>

</li>
</ul>
<p translation-result="on">下列程式碼為每個元件載入了一些測試工具：</p><p translation-origin="off">The following code loads harnesses for each of these components:</p>

<pre><code class="language-ts"><span class="hljs-keyword">let</span> fixture: ComponentFixture&lt;MyDialogButton&gt;;
<span class="hljs-keyword">let</span> loader: HarnessLoader;
<span class="hljs-keyword">let</span> rootLoader: HarnessLoader;

beforeEach(<span class="hljs-function">() =&gt;</span> {
  fixture = TestBed.createComponent(MyDialogButton);
  loader = TestbedHarnessEnvironment.loader(fixture);
  rootLoader = TestbedHarnessEnvironment.documentRootLoader(fixture);
});

it(<span class="hljs-string">'loads harnesses'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-comment">// Load a harness for the bootstrapped component with `harnessForFixture`</span>
  dialogButtonHarness =
      <span class="hljs-keyword">await</span> TestbedHarnessEnvironment.harnessForFixture(fixture, MyDialogButtonHarness);

  <span class="hljs-comment">// The button element is inside the fixture's root element, so we use `loader`.</span>
  <span class="hljs-keyword">const</span> buttonHarness = <span class="hljs-keyword">await</span> loader.getHarness(MyButtonHarness);

  <span class="hljs-comment">// Click the button to open the dialog</span>
  <span class="hljs-keyword">await</span> buttonHarness.click();

  <span class="hljs-comment">// The dialog is appended to `document.body`, outside of the fixture's root element,</span>
  <span class="hljs-comment">// so we use `rootLoader` in this case.</span>
  <span class="hljs-keyword">const</span> dialogHarness = <span class="hljs-keyword">await</span> rootLoader.getHarness(MyDialogHarness);

  <span class="hljs-comment">// ... make some assertions</span>
});
</code></pre>
<p translation-result="on"><code>SeleniumWebDriverHarnessEnvironment</code> 有一個提供單個靜態方法的 API：</p><p translation-origin="off"><code>SeleniumWebDriverHarnessEnvironment</code> has an API that offers a single static method:</p>

<table>
<thead>
<tr>
<th><nt-wrapper translation-result="on">方法</nt-wrapper><nt-wrapper translation-origin="off">Method</nt-wrapper></th>
<th><nt-wrapper translation-result="on">說明</nt-wrapper><nt-wrapper translation-origin="off">Description</nt-wrapper></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>loader(): HarnessLoader</code></td>
<td><nt-wrapper translation-result="on">獲取 <code>HarnessLoader</code> 實例，該實例以該文件的根元素為根。</nt-wrapper><nt-wrapper translation-origin="off">Gets a <code>HarnessLoader</code> instance for the current HTML document, rooted at the document's root element.</nt-wrapper></td>
</tr>

</tbody></table>
<p translation-result="on">雖然 Selenium WebDriver 不知道怎麼用夾具，但這個環境下的 API 比較簡單。<code>loader()</code> 方法回傳的 <code>HarnessLoader</code> 應足以載入所有必需的 <code>ComponentHarness</code> 實例。</p><p translation-origin="off">Since Selenium WebDriver does not deal with fixtures, the API in this environment is simpler. The
<code>HarnessLoader</code> returned by the <code>loader()</code> method should be sufficient for loading all necessary
<code>ComponentHarness</code> instances.</p>

<p translation-result="on">請注意，在各種環境中，測試工具的行為可能並不<em>完全相同</em>。當用戶點選或輸入某個元素時，真正的瀏覽器生成的事件序列與單元測試中生成的模擬事件序列之間總有一些區別。不過，CDK 會盡最大努力規範其行為，並模擬序列中最重要的事件。</p><p translation-origin="off">Please note that harnesses may not behave <em>exactly</em> the same in all environments. There will always
be some difference between the real browser-generated event sequence when a user clicks or types in
an element, versus the simulated event sequence generated in unit tests. Instead, the CDK makes a
best effort to normalize the behavior and simulate the most important events in the sequence.</p>


        <h4 id="creating-harnesses-with-harnessloader" class="docs-header-link" translation-result="on">
          <span header-link="使用-harnessloader-建立測試工具"></span>
          使用 <code>HarnessLoader</code> 建立測試工具
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="creating-harnesses-with-harnessloader"></span>
          Creating harnesses with <code>HarnessLoader</code>
        </h4>
      
        
      <p translation-result="on">該類別的實例對應一個特定的 DOM 元素（此載入器的『根元素』），用於為該根元素下的元素建立 <code>ComponentHarness</code>。</p><p translation-origin="off">Instances of this class correspond to a specific DOM element (the "root element" of the loader) and
are used to create <code>ComponentHarness</code> instances for elements under this root element.</p>

<p translation-result="on"><code>HarnessLoader</code> 實例有以下幾種方法：</p><p translation-origin="off"><code>HarnessLoader</code> instances have the following methods:</p>

<table>
<thead>
<tr>
<th><nt-wrapper translation-result="on">方法</nt-wrapper><nt-wrapper translation-origin="off">Method</nt-wrapper></th>
<th><nt-wrapper translation-result="on">說明</nt-wrapper><nt-wrapper translation-origin="off">Description</nt-wrapper></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>getChildLoader(selector: string): Promise&lt;HarnessLoader&gt;</code></td>
<td><nt-wrapper translation-result="on">在 <code>HarnessLoader</code> 的根元素下搜尋對應指定選擇器的元素，並回傳以第一個對應元素為根的 <code>HarnessLoader</code></nt-wrapper><nt-wrapper translation-origin="off">Searches for an element matching the given selector below the root element of this <code>HarnessLoader</code>, and returns a new <code>HarnessLoader</code> rooted at the first matching element</nt-wrapper></td>
</tr>

<tr>
<td><code>getAllChildLoaders(selector: string): Promise&lt;HarnessLoader[]&gt;</code></td>
<td><nt-wrapper translation-result="on">行為類似於 <code>getChildLoader</code>，但回傳一個 HarnessLoader 實例陣列，給每個對應的元素一個實例，而不是只給第一個對應的元素</nt-wrapper><nt-wrapper translation-origin="off">Acts like <code>getChildLoader</code>, but returns an array of <code>HarnessLoader</code> instances, one for each matching element, rather than just the first matching element</nt-wrapper></td>
</tr>

<tr>
<td><code>getHarness&lt;T extends ComponentHarness&gt;(harnessType: ComponentHarnessConstructor&lt;T&gt; &amp;verbar; HarnessPredicate&lt;T&gt;): Promise&lt;T&gt;</code></td>
<td><nt-wrapper translation-result="on">在 <code>HarnessLoader</code> 的根元素下面搜尋指定的 <code>ComponentHarness</code> 或 <code>HarnessPredicate</code> 類別的實例，並回傳與第一個對應元素對應的測試工具的實例</nt-wrapper><nt-wrapper translation-origin="off">Searches for an instance of the given <code>ComponentHarness</code> class or <code>HarnessPredicate</code> below the root element of this <code>HarnessLoader</code> and returns an instance of the harness corresponding to the first matching element</nt-wrapper></td>
</tr>

<tr>
<td><code>getAllHarnesses&lt;T extends ComponentHarness&gt;(harnessType: ComponentHarnessConstructor&lt;T&gt; &amp;verbar; HarnessPredicate&lt;T&gt;): Promise&lt;T[]&gt;</code></td>
<td><nt-wrapper translation-result="on">行為類似於 <code>getHarness</code>，但會回傳一個測試工具實例的陣列，給每個對應的元素一個實例，而不只是只給第一個對應的元素</nt-wrapper><nt-wrapper translation-origin="off">Acts like <code>getHarness</code>, but returns an array of harness instances, one for each matching element, rather than just the first matching element</nt-wrapper></td>
</tr>

</tbody></table>
<p translation-result="on">呼叫 <code>getHarness</code> 和 <code>getAllHarnesses</code> 的引數可以是 <code>ComponentHarness</code> 的子類別或 <code>HarnessPredicate</code>。<code>HarnessPredicate</code> 對搜尋應用了額外的限制（比如搜尋一些帶有特定文字的按鈕等）。<a href="#filtering-harness-instances-with-harnesspredicate"><code>HarnessPredicate</code></a> 的<a href="#filtering-harness-instances-with-harnesspredicate">詳細訊息</a>在<a href="#api-for-component-harness-authors">元件工具作者</a>的 API 部分討論。元件工具的作者應該在 <code>ComponentHarness</code> 子類別中提供了一些建立 <code>HarnessPredicate</code> 實例的便利方法。但是，如果測試工具作者提供的 API 不夠用，你也可以手動建立它們。</p><p translation-origin="off">Calls to <code>getHarness</code> and <code>getAllHarnesses</code> can either take <code>ComponentHarness</code> subclass or a
<code>HarnessPredicate</code>. <code>HarnessPredicate</code> applies additional restrictions to the search (e.g. searching
for a button that has some particular text, etc). The
<a href="#filtering-harness-instances-with-harnesspredicate">details of <code>HarnessPredicate</code></a> are discussed in
the <a href="#api-for-component-harness-authors">API for component harness authors</a>; harness authors should
provide convenience methods on their <code>ComponentHarness</code> subclass to facilitate the creation of
<code>HarnessPredicate</code> instances. However, if the harness author's API is not sufficient, they can be
created manually.</p>


        <h4 id="change-detection" class="docs-header-link" translation-result="on">
          <span header-link="變更檢測"></span>
          變更檢測
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="change-detection"></span>
          Change detection
        </h4>
      
        
      <p translation-result="on">預設情況下，測試工具會在讀取 DOM 元素的狀態之前和與 DOM 元素互動之後執行 Angular 變更檢測。這雖然在大多數情況下很方便，但有時候你需要對變更檢測進行更細粒度的控制。例如，你可能希望在非同步操作掛起時檢查某個元件的狀態。在這些情況下，你可以使用 <code>manualChangeDetection</code> 函式來停用對程式碼區塊的自動變更檢測。例如：</p><p translation-origin="off">By default, test harnesses will run Angular's change detection before reading the state of a DOM
element and after interacting with a DOM element. While convenient in most cases, there may be times
that you need finer-grained control over change detection. For example, you may want to check the
state of a component while an async operation is pending. In these cases you can use the
<code>manualChangeDetection</code> function to disable automatic handling of change detection for a block of
code. For example:</p>

<pre><code class="language-ts">it(<span class="hljs-string">'checks state while async action is in progress'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">const</span> buttonHarness = loader.getHarness(MyButtonHarness);
  <span class="hljs-keyword">await</span> manualChangeDetection(<span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">await</span> buttonHarness.click();
    fixture.detectChanges();
    <span class="hljs-comment">// Check expectations while async click operation is in progress.</span>
    expect(isProgressSpinnerVisible()).toBe(<span class="hljs-literal">true</span>);
    <span class="hljs-keyword">await</span> fixture.whenStable();
    <span class="hljs-comment">// Check expectations after async click operation complete.</span>
    expect(isProgressSpinnerVisible()).toBe(<span class="hljs-literal">false</span>);
  });
});
</code></pre>

        <h4 id="working-with-asynchronous-component-harness-methods" class="docs-header-link" translation-result="on">
          <span header-link="使用元件測試工具的非同步方法"></span>
          使用元件測試工具的非同步方法
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="working-with-asynchronous-component-harness-methods"></span>
          Working with asynchronous component harness methods
        </h4>
      
        
      <p translation-result="on">為了支援單元測試和端到端測試，並把測試與非同步行為的變化隔離開來，測試工具幾乎的所有方法都是非同步的，並回傳一個 <code>Promise</code>；因此，Angular 團隊建議使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function">ES2017 的 <code>async</code> / <code>await</code> 語法</a>來提高測試的可讀性。</p><p translation-origin="off">To support both unit and end-to-end tests, and to insulate tests against changes in
asynchronous behavior, almost all harness methods are asynchronous and return a <code>Promise</code>;
therefore, the Angular team recommends using
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function">ES2017 <code>async</code>/<code>await</code> syntax</a>
to improve the test readability.</p>

<p translation-result="on">注意，<code>await</code> 語句會阻塞測試的執行，直到相關的 <code>Promise</code> 被解析為止。有時，你可能希望同時執行多個動作，並等待它們全部完成，而不是按順序執行每個動作。例如，從單個元件中讀取多個屬性。在這種情況下，請使用 <code>parallel</code> 函式來並行處理這些操作。parallel 函式與 <code>Promise.all</code> 工作方式類似，但同時最佳化了變更檢測，因此它的執行次數不會太多。以下程式碼示範如何透過 <code>parallel</code> 從測試工具中讀取多個屬性：</p><p translation-origin="off">Note that <code>await</code> statements block the execution of your test until the associated <code>Promise</code>
resolves. Occasionally, you may want to perform multiple actions simultaneously and wait until
they're all done rather than performing each action sequentially. For example, reading multiple
properties off a single component. In these situations use the <code>parallel</code> function to parallelize
the operations. The parallel function works similarly to <code>Promise.all</code>, while also optimizing change
detection, so it is not run an excessive number of times. The following code demonstrates how you
can read multiple properties from a harness with <code>parallel</code>:</p>

<pre><code class="language-ts">it(<span class="hljs-string">'reads properties in parallel'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">const</span> checkboxHarness = loader.getHarness(MyCheckboxHarness);
  <span class="hljs-comment">// Read the checked and intermediate properties simultaneously.</span>
  <span class="hljs-keyword">const</span> [checked, indeterminate] = <span class="hljs-keyword">await</span> parallel(<span class="hljs-function">() =&gt;</span> [
    checkboxHarness.isChecked(),
    checkboxHarness.isIndeterminate()
  ]);
  expect(checked).toBe(<span class="hljs-literal">false</span>);
  expect(indeterminate).toBe(<span class="hljs-literal">true</span>);
});
</code></pre>

        <h3 id="api-for-component-harness-authors" class="docs-header-link" translation-result="on">
          <span header-link="元件測試工具作者的-api"></span>
          元件測試工具作者的 API
        </h3><h3 class="docs-header-link" translation-origin="off">
          <span header-link="api-for-component-harness-authors"></span>
          API for component harness authors
        </h3>
      
        
      <p translation-result="on">元件測試工具作者是那些需要維護一些可複用的 Angular 元件並希望為它建立一個測試工具的開發人員，元件使用者可以在測試中使用它。
例如，可能是第三方 Angular 元件庫的作者，也可能是為大型 Angular 應用維護一組通用元件的開發人員。</p><p translation-origin="off">Component harness authors are developers who maintain some reusable Angular component, and want to
create a test harness for it, that users of the component can use in their tests. For example, this
could be an author of a third party Angular component library or a developer who maintains a set of
common components for a large Angular application.</p>


        <h4 id="extending-componentharness" class="docs-header-link" translation-result="on">
          <span header-link="擴充套件-componentharness"></span>
          擴充套件 <code>ComponentHarness</code>
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="extending-componentharness"></span>
          Extending <code>ComponentHarness</code>
        </h4>
      
        
      <p translation-result="on">抽象類別 <code>ComponentHarness</code> 是所有元件測試工具的基底類別。要建立自定義元件測試工具，請擴充套件 <code>ComponentHarness</code> 並實現其靜態屬性 <code>hostSelector</code>。<code>hostSelector</code> 屬性用於標識 DOM 中與該測試工具子類別相對應的元素。在大多數情況下，<code>hostSelector</code> 應該與相應的 <code>Component</code> 或 <code>Directive</code> 的 <code>selector</code> 相同。例如，考慮一個簡單的彈出框元件：</p><p translation-origin="off">The abstract <code>ComponentHarness</code> class is the base class for all component harnesses. To create a
custom component harness, extend <code>ComponentHarness</code> and implement the static property
<code>hostSelector</code>. The <code>hostSelector</code> property identifies elements in the DOM that match this harness
subclass. In most cases, the <code>hostSelector</code> should be the same as the <code>selector</code> of the corresponding
<code>Component</code> or <code>Directive</code>. For example, consider a simple popup component:</p>

<pre><code class="language-ts"><span class="hljs-meta">@Component</span>({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">'my-popup'</span>,
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
    &lt;button (click)="toggle()"&gt;{{triggerText}}&lt;/button&gt;
    &lt;div *ngIf="open" class="my-popup-content"&gt;&lt;ng-content&gt;&lt;/ng-content&gt;&lt;/div&gt;
  `</span>
})
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPopup</span> </span>{
  <span class="hljs-meta">@Input</span>() triggerText: <span class="hljs-built_in">string</span>;

  open = <span class="hljs-literal">false</span>;

  <span class="hljs-function"><span class="hljs-title">toggle</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-built_in">this</span>.open = !<span class="hljs-built_in">this</span>.open;
  }
}
</code></pre>
<p translation-result="on">在這種情況下，該組件的最簡測試工具如下所示：</p><p translation-origin="off">In this case, a minimal harness for the component would look like the following:</p>

<pre><code class="language-ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPopupHarness</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ComponentHarness</span> </span>{
  <span class="hljs-keyword">static</span> hostSelector = <span class="hljs-string">'my-popup'</span>;
}
</code></pre>
<p translation-result="on">雖然 <code>ComponentHarness</code> 子類別只需要 <code>hostSelector</code> 屬性，但大多數測試工具還應該使用靜態方法 <code>with</code> 來生成 <code>HarnessPredicate</code> 實例。下面的 <a href="#filtering-harness-instances-with-harnesspredicate"><code>HarnessPredicate</code></a> 部分會更詳細介紹這一點。</p><p translation-origin="off">While <code>ComponentHarness</code> subclasses require only the <code>hostSelector</code> property, most harnesses should
also implement a static <code>with</code> method to generate <code>HarnessPredicate</code> instances. The
<a href="#filtering-harness-instances-with-harnesspredicate"><code>HarnessPredicate</code></a> section below covers this
in more detail.</p>


        <h4 id="finding-elements-in-the-components-dom" class="docs-header-link" translation-result="on">
          <span header-link="在元件的-dom-中查詢元素"></span>
          在元件的 DOM 中查詢元素
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="finding-elements-in-the-components-dom"></span>
          Finding elements in the component's DOM
        </h4>
      
        
      <p translation-result="on"><code>ComponentHarness</code> 子類別的每個實例都表示相應元件的一個特定實例。你可以用 <code>ComponentHarness</code> 類別的 <code>host</code> 方法訪問元件的宿主元素。</p><p translation-origin="off">Each instance of a <code>ComponentHarness</code> subclass represents a particular instance of the
corresponding component. You can access the component's host element via the <code>host</code> method from
the <code>ComponentHarness</code> base class.</p>

<p translation-result="on"><code>ComponentHarness</code> 還提供了幾種在元件 DOM 中定位元素的方法。它們是 <code>locatorFor</code>、<code>locatorForOptional</code> 和 <code>locatorForAll</code>。但請注意，這些方法並不直接查詢元素，而是會<em>建立</em>能尋找元素的函式。這種方式可以防止快取對過時元素的引用。例如，當一個 <code>ngIf</code> 先隱藏再顯示一個元素時，其結果是一個新的 DOM 元素；使用函式可以確保測試總能引用 DOM 的當前狀態。</p><p translation-origin="off"><code>ComponentHarness</code> additionally offers several methods for locating elements within the component's
DOM. These methods are <code>locatorFor</code>, <code>locatorForOptional</code>, and <code>locatorForAll</code>.
Note, though, that these methods do not directly find elements. Instead, they <em>create functions</em>
that find elements. This approach safeguards against caching references to out-of-date elements. For
example, when an <code>ngIf</code> hides and then shows an element, the result is a new DOM element; using
functions ensures that tests always reference the current state of the DOM.</p>

<table>
<thead>
<tr>
<th><nt-wrapper translation-result="on">方法</nt-wrapper><nt-wrapper translation-origin="off">Method</nt-wrapper></th>
<th><nt-wrapper translation-result="on">說明</nt-wrapper><nt-wrapper translation-origin="off">Description</nt-wrapper></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>host(): Promise&lt;TestElement&gt;</code></td>
<td><nt-wrapper translation-result="on">回傳相應元件實例的宿主元素的 <code>Promise</code></nt-wrapper><nt-wrapper translation-origin="off">Returns a <code>Promise</code> for the host element of the corresponding component instance.</nt-wrapper></td>
</tr>

<tr>
<td><code>locatorFor(selector: string): () =&gt; Promise&lt;TestElement&gt;</code></td>
<td><nt-wrapper translation-result="on">建立一個函式，該函式在被呼叫時會回傳與指定選擇器對應的第一個元素的 <code>Promise</code>。如果找不到對應的元素，<code>Promise</code> 就會拒絕。</nt-wrapper><nt-wrapper translation-origin="off">Creates a function that returns a <code>Promise</code> for the first element matching the given selector when called. If no matching element is found, the <code>Promise</code> rejects.</nt-wrapper></td>
</tr>

<tr>
<td><code>locatorForOptional(selector: string): () =&gt; Promise&lt;TestElement &amp;verbar; null&gt;</code></td>
<td><nt-wrapper translation-result="on">建立一個函式，該函式在被呼叫時會回傳與指定選擇器對應的第一個元素的 <code>Promise</code>。如果找不到對應的元素，則會解析成攜帶 <code>null</code> 的 <code>Promise</code>。</nt-wrapper><nt-wrapper translation-origin="off">Creates a function that returns a <code>Promise</code> for the first element matching the given selector when called. If no matching element is found, the <code>Promise</code> is resolved with <code>null</code>.</nt-wrapper></td>
</tr>

<tr>
<td><code>locatorForAll(selector: string): () =&gt; Promise&lt;TestElement[]&gt;</code></td>
<td><nt-wrapper translation-result="on">建立一個函式，它回傳一個 <code>Promise</code> 以便在呼叫時回傳與指定選擇器對應的所有元素的清單。</nt-wrapper><nt-wrapper translation-origin="off">Creates a function that returns a <code>Promise</code> for a list of all elements matching the given selector when called.</nt-wrapper></td>
</tr>

</tbody></table>
<p translation-result="on">例如，<code>MyPopupHarness</code> 類可以提供獲取觸發器和內容元素的方法，如下所示：</p><p translation-origin="off">For example, the <code>MyPopupHarness</code> class discussed above could provide methods to get the trigger
and content elements as follows:</p>

<pre><code class="language-ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPopupHarness</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ComponentHarness</span> </span>{
  <span class="hljs-keyword">static</span> hostSelector = <span class="hljs-string">'my-popup'</span>;

  <span class="hljs-comment">/** Gets the trigger element */</span>
  getTriggerElement = <span class="hljs-built_in">this</span>.locatorFor(<span class="hljs-string">'button'</span>);

  <span class="hljs-comment">/** Gets the content element. */</span>
  getContentElement = <span class="hljs-built_in">this</span>.locatorForOptional(<span class="hljs-string">'.my-popup-content'</span>);
}
</code></pre>

        <h4 id="working-with-testelement-instances" class="docs-header-link" translation-result="on">
          <span header-link="使用-testelement-實例"></span>
          使用 <code>TestElement</code> 實例
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="working-with-testelement-instances"></span>
          Working with <code>TestElement</code> instances
        </h4>
      
        
      <p translation-result="on">使用上述定位器方法建立的函式都回傳了 <code>TestElement</code> 實例。<code>TestElement</code> 提供了許多與底層 DOM 互動的方法：</p><p translation-origin="off">The functions created with the locator methods described above all return <code>TestElement</code> instances.
<code>TestElement</code> offers a number of methods to interact with the underlying DOM:</p>

<table>
<thead>
<tr>
<th><nt-wrapper translation-result="on">方法</nt-wrapper><nt-wrapper translation-origin="off">Method</nt-wrapper></th>
<th><nt-wrapper translation-result="on">說明</nt-wrapper><nt-wrapper translation-origin="off">Description</nt-wrapper></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>blur(): Promise&lt;void&gt;</code></td>
<td><nt-wrapper translation-result="on">讓此元素失焦。</nt-wrapper><nt-wrapper translation-origin="off">Blurs the element.</nt-wrapper></td>
</tr>

<tr>
<td><code>clear(): Promise&lt;void&gt;</code></td>
<td><nt-wrapper translation-result="on">清除此元素中的文字（僅適用於 <code>&lt;input&gt;</code> 和 <code>&lt;textarea&gt;</code> ）。</nt-wrapper><nt-wrapper translation-origin="off">Clears the text in the element (intended for <code>&lt;input&gt;</code> and <code>&lt;textarea&gt;</code> only).</nt-wrapper></td>
</tr>

<tr>
<td><code>click(relativeX?: number, relativeY?: number): Promise&lt;void&gt;</code></td>
<td><nt-wrapper translation-result="on">單擊此元素（相對於此元素左上角的指定位置）。</nt-wrapper><nt-wrapper translation-origin="off">Clicks the element (at the given position relative to the element's top-left corner).</nt-wrapper></td>
</tr>

<tr>
<td><code>focus(): Promise&lt;void&gt;</code></td>
<td><nt-wrapper translation-result="on">讓此元素獲得焦點。</nt-wrapper><nt-wrapper translation-origin="off">Focuses the element.</nt-wrapper></td>
</tr>

<tr>
<td><code>getCssValue(property: string): Promise&lt;string&gt;</code></td>
<td><nt-wrapper translation-result="on">獲取此元素指定 CSS 屬性的計算值。</nt-wrapper><nt-wrapper translation-origin="off">Gets the computed value of the given CSS property for the element.</nt-wrapper></td>
</tr>

<tr>
<td><code>hover(): Promise&lt;void&gt;</code></td>
<td><nt-wrapper translation-result="on">懸停在此元素上方。</nt-wrapper><nt-wrapper translation-origin="off">Hovers over the element.</nt-wrapper></td>
</tr>

<tr>
<td><code>sendKeys(modifiers?: ModifierKeys, ...keys: (string &amp;verbar; TestKey)[]): Promise&lt;void&gt;</code></td>
<td><nt-wrapper translation-result="on">給此元素傳送指定的按鍵清單（可以帶修飾鍵）。</nt-wrapper><nt-wrapper translation-origin="off">Sends the given list of key presses to the element (with optional modifier keys).</nt-wrapper></td>
</tr>

<tr>
<td><code>text(): Promise&lt;string&gt;</code></td>
<td><nt-wrapper translation-result="on">獲取此元素的文字內容</nt-wrapper><nt-wrapper translation-origin="off">Gets the text content of the element</nt-wrapper></td>
</tr>

<tr>
<td><code>getAttribute(name: string): Promise&lt;string &amp;verbar; null&gt;</code></td>
<td><nt-wrapper translation-result="on">從此元素獲取指定的 HTML 屬性的值。</nt-wrapper><nt-wrapper translation-origin="off">Gets the value of the given HTML attribute for the element.</nt-wrapper></td>
</tr>

<tr>
<td><code>hasClass(name: string): Promise&lt;boolean&gt;</code></td>
<td><nt-wrapper translation-result="on">檢查此元素是否已應用了指定的類。</nt-wrapper><nt-wrapper translation-origin="off">Checks whether the element has the given class applied.</nt-wrapper></td>
</tr>

<tr>
<td><code>getDimensions(): Promise&lt;ElementDimensions&gt;</code></td>
<td><nt-wrapper translation-result="on">獲取此元素的尺寸。</nt-wrapper><nt-wrapper translation-origin="off">Gets the dimensions of the element.</nt-wrapper></td>
</tr>

<tr>
<td><code>getProperty(name: string): Promise&lt;any&gt;</code></td>
<td><nt-wrapper translation-result="on">從此元素獲取指定的 JS 屬性的值。</nt-wrapper><nt-wrapper translation-origin="off">Gets the value of the given JS property for the element.</nt-wrapper></td>
</tr>

<tr>
<td><code>matchesSelector(selector: string): Promise&lt;boolean&gt;</code></td>
<td><nt-wrapper translation-result="on">檢查此元素是否與指定的 CSS 選擇器對應。</nt-wrapper><nt-wrapper translation-origin="off">Checks whether the element matches the given CSS selector.</nt-wrapper></td>
</tr>

<tr>
<td><code>setInputValue(value: string): Promise&lt;void&gt;;</code></td>
<td><nt-wrapper translation-result="on">設定輸入屬性的值。</nt-wrapper><nt-wrapper translation-origin="off">Sets the value of a property of an input.</nt-wrapper></td>
</tr>

<tr>
<td><code>selectOptions(...optionIndexes: number[]): Promise&lt;void&gt;;</code></td>
<td><nt-wrapper translation-result="on">在原生 <code>select</code> 元素中指定索引處的候選項。</nt-wrapper><nt-wrapper translation-origin="off">Selects the options at the specified indexes inside of a native <code>select</code> element.</nt-wrapper></td>
</tr>

<tr>
<td><code>dispatchEvent(name: string, data?: Record&lt;string, EventData&gt;): Promise&lt;void&gt;;</code></td>
<td><nt-wrapper translation-result="on">派發具有特定名稱的事件。</nt-wrapper><nt-wrapper translation-origin="off">Dispatches an event with a particular name.</nt-wrapper></td>
</tr>

</tbody></table>
<p translation-result="on"><code>TestElement</code> 是一種抽象設計，適用於不同的測試環境（Karma，Selenium WebDriver 等）。在使用測試工具時，你應該透過這個介面來進行所有的 DOM 互動。其他訪問 DOM 元素的方法（例如 <code>document.querySelector</code> ）並不適用於所有的測試環境。</p><p translation-origin="off"><code>TestElement</code> is an abstraction designed to work across different test environments (Karma,
Selenium WebDriver, etc). When using harnesses, you should perform all DOM interaction via this interface.
Other means of accessing DOM elements (e.g. <code>document.querySelector</code>) will not work in all test
environments.</p>

<p translation-result="on">最好的做法是，你不應該把 <code>TestElement</code> 實例公開給測試工具的使用者，除非它是由元件消費者直接定義的元素（比如宿主元素）。公開 <code>TestElement</code> 實例會讓使用者依賴元件的內部 DOM 結構。</p><p translation-origin="off">As a best practice, you should not expose <code>TestElement</code> instances to users of a harness
unless its an element the component consumer defines directly (e.g. the host element). Exposing
<code>TestElement</code> instances for internal elements leads users to depend on a component's internal DOM
structure.</p>

<p translation-result="on">相反，要為最終使用者可能執行的操作或可能要檢查的狀態提供更加專用的方法。例如，<code>MyPopupHarness</code> 可以提供像 <code>toggle</code> 和 <code>isOpen</code> 之類的方法：</p><p translation-origin="off">Instead, provide more narrow-focused methods for particular actions the end-user will
take or particular state they may want to check. For example, <code>MyPopupHarness</code> could provide methods
like <code>toggle</code> and <code>isOpen</code>:</p>

<pre><code class="language-ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPopupHarness</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ComponentHarness</span> </span>{
  <span class="hljs-keyword">static</span> hostSelector = <span class="hljs-string">'my-popup'</span>;

  <span class="hljs-keyword">protected</span> getTriggerElement = <span class="hljs-built_in">this</span>.locatorFor(<span class="hljs-string">'button'</span>);
  <span class="hljs-keyword">protected</span> getContentElement = <span class="hljs-built_in">this</span>.locatorForOptional(<span class="hljs-string">'.my-popup-content'</span>);

  <span class="hljs-comment">/** Toggles the open state of the popup. */</span>
  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">toggle</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">const</span> trigger = <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.getTriggerElement();
    <span class="hljs-keyword">return</span> trigger.click();
  }

  <span class="hljs-comment">/** Checks if the popup us open. */</span>
  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">isOpen</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">const</span> content = <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.getContentElement();
    <span class="hljs-keyword">return</span> !!content;
  }
}
</code></pre>

        <h4 id="loading-harnesses-for-subcomponents" class="docs-header-link" translation-result="on">
          <span header-link="為子元件載入測試工具"></span>
          為子元件載入測試工具
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="loading-harnesses-for-subcomponents"></span>
          Loading harnesses for subcomponents
        </h4>
      
        
      <p translation-result="on">較大的元件通常是由較小的元件組合而成的。你也可以在元件測試工具中反映出這種結構。<code>ComponentHarness</code> 上的每個 <code>locatorFor</code> 族方法都有一個備用簽名，可以用來定位子級測試工具而不是元素。</p><p translation-origin="off">Larger components often compose smaller components. You can reflect this structure in a
component's harness as well. Each of the <code>locatorFor</code> methods on <code>ComponentHarness</code> discussed
earlier has an alternate signature that can be used for locating sub-harnesses rather than elements.</p>

<table>
<thead>
<tr>
<th><nt-wrapper translation-result="on">方法</nt-wrapper><nt-wrapper translation-origin="off">Method</nt-wrapper></th>
<th><nt-wrapper translation-result="on">說明</nt-wrapper><nt-wrapper translation-origin="off">Description</nt-wrapper></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>locatorFor&lt;T extends ComponentHarness&gt;(harnessType: ComponentHarnessConstructor&lt;T&gt;): () =&gt; Promise&lt;T&gt;</code></td>
<td><nt-wrapper translation-result="on">建立一個函式，該函式在被呼叫時回傳第一個對應指定測試工具型別的測試工具的 <code>Promise</code>；如果找不到對應的測試工具，<code>Promise</code> 就會拒絕。</nt-wrapper><nt-wrapper translation-origin="off">Creates a function that returns a <code>Promise</code> for the first harness matching the given harness type when called. If no matching harness is found, the <code>Promise</code> rejects.</nt-wrapper></td>
</tr>

<tr>
<td><code>locatorForOptional&lt;T extends ComponentHarness&gt;(harnessType: ComponentHarnessConstructor&lt;T&gt;): () =&gt; Promise&lt;T &amp;verbar; null&gt;</code></td>
<td><nt-wrapper translation-result="on">建立一個函式，該函式在被呼叫時回傳第一個對應指定測試工具型別的測試工具的 <code>Promise</code>；如果找不到對應的工具，就會解析成攜帶 <code>null</code> 的 <code>Promise</code>。</nt-wrapper><nt-wrapper translation-origin="off">Creates a function that returns a <code>Promise</code> for the first harness matching the given harness type when called. If no matching harness is found, the <code>Promise</code> is resolved with <code>null</code>.</nt-wrapper></td>
</tr>

<tr>
<td><code>locatorForAll&lt;T extends ComponentHarness&gt;(harnessType: ComponentHarnessConstructor&lt;T&gt;): () =&gt; Promise&lt;T[]&gt;</code></td>
<td><nt-wrapper translation-result="on">建立一個函式，該函式在被呼叫時回傳一個 <code>Promise</code>，攜帶對應到指定測試工具型別的所有測試工具清單。</nt-wrapper><nt-wrapper translation-origin="off">Creates a function that returns a <code>Promise</code> for a list of all harnesses matching the given harness type when called.</nt-wrapper></td>
</tr>

</tbody></table>
<p translation-result="on">例如，考慮使用上面示範過的彈出選單來建立選單：</p><p translation-origin="off">For example, consider a menu build using the popup shown above:</p>

<pre><code class="language-ts"><span class="hljs-meta">@Component</span>({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">'my-menu'</span>,
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
    &lt;my-popup&gt;
      &lt;ng-content&gt;&lt;/ng-content&gt;
    &lt;/my-popup&gt;
  `</span>
})
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMenu</span> </span>{
  <span class="hljs-meta">@Input</span>() triggerText: <span class="hljs-built_in">string</span>;

  <span class="hljs-meta">@ContentChildren</span>(MyMenuItem) items: QueryList&lt;MyMenuItem&gt;;
}

<span class="hljs-meta">@Directive</span>({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">'my-menu-item'</span>
})
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMenuItem</span> </span>{}
</code></pre>
<p translation-result="on"><code>MyMenu</code> 的測試工具就可以利用 <code>MyPopup</code> 和 <code>MyMenuItem</code> 的其他測試工具：</p><p translation-origin="off">The harness for <code>MyMenu</code> can then take advantage of other harnesses for <code>MyPopup</code> and <code>MyMenuItem</code>:</p>

<pre><code class="language-ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMenuHarness</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ComponentHarness</span> </span>{
  <span class="hljs-keyword">static</span> hostSelector = <span class="hljs-string">'my-menu'</span>;

  <span class="hljs-keyword">protected</span> getPopupHarness = <span class="hljs-built_in">this</span>.locatorFor(MyPopupHarness);

  <span class="hljs-comment">/** Gets the currently shown menu items (empty list if menu is closed). */</span>
  getItems = <span class="hljs-built_in">this</span>.locatorForAll(MyMenuItemHarness);

  <span class="hljs-comment">/** Toggles open state of the menu. */</span>
  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">toggle</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">const</span> popupHarness = <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.getPopupHarness();
    <span class="hljs-keyword">return</span> popupHarness.toggle();
  }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMenuItemHarness</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ComponentHarness</span> </span>{
  <span class="hljs-keyword">static</span> hostSelector = <span class="hljs-string">'my-menu-item'</span>;
}
</code></pre>

        <h4 id="filtering-harness-instances-with-harnesspredicate" class="docs-header-link" translation-result="on">
          <span header-link="使用-harnesspredicate-過濾測試工具實例"></span>
          使用 <code>HarnessPredicate</code> 過濾測試工具實例
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="filtering-harness-instances-with-harnesspredicate"></span>
          Filtering harness instances with <code>HarnessPredicate</code>
        </h4>
      
        
      <p translation-result="on">當一個頁面包含特定元件的多個實例時，你可能需要根據該組件的某些屬性進行過濾，以得到一個特定的元件實例。例如，你可能想要一個帶有特定文字的按鈕，或一個帶有特定 ID 的選單。<code>HarnessPredicate</code> 可以為 <code>ComponentHarness</code> 的子類別按一定的標準捕獲它們。雖然測試作者也能手動建立 <code>HarnessPredicate</code> 實例，但 <code>ComponentHarness</code> 子類別提供了一個輔助方法來為常用的過濾器構造謂詞，這更容易。</p><p translation-origin="off">When a page contains multiple instances of a particular component, you may want to filter based on
some property of the component to get a particular component instance. For example, you may want
a button with some specific text, or a menu with a specific ID. The <code>HarnessPredicate</code>
class can capture criteria like this for a <code>ComponentHarness</code> subclass. While the
test author is able to construct <code>HarnessPredicate</code> instances manually, it's easier when the
<code>ComponentHarness</code> subclass provides a helper method to construct predicates for common filters.</p>

<p translation-result="on">建議在每個 <code>ComponentHarness</code> 子類別的 <code>with</code> 方法中提供這個輔助方法，它回傳該類別的 <code>HarnessPredicate</code>。這讓測試作者可以編寫易於理解的程式碼，例如 <code>loader.getHarness(MyMenuHarness.with({selector: '#menu1'}))</code>。除了標準的 <code>selector</code> 和 <code>ancestor</code> 選項之外，<code>with</code> 方法還應該新增對特定的子類別有意義的其他選項。</p><p translation-origin="off">The recommended approach to providing this helper is to create a static <code>with</code> method on each
<code>ComponentHarness</code> subclass that returns a <code>HarnessPredicate</code> for that class. This allows test
authors to write easily understandable code, e.g.
<code>loader.getHarness(MyMenuHarness.with({selector: '#menu1'}))</code>. In addition to the standard
<code>selector</code> and <code>ancestor</code> options, the <code>with</code> method should add any other options that make sense
for the particular subclass.</p>

<p translation-result="on">需要新增其他選項的測試工具應該根據需要擴充套件 <code>BaseHarnessFilters</code> 介面和其它可選屬性。<code>HarnessPredicate</code> 為新增選項提供了一些便利方法。</p><p translation-origin="off">Harnesses that need to add additional options should extend the <code>BaseHarnessFilters</code> interface and
additional optional properties as needed. <code>HarnessPredicate</code> provides several convenience methods
for adding options.</p>

<table>
<thead>
<tr>
<th><nt-wrapper translation-result="on">方法</nt-wrapper><nt-wrapper translation-origin="off">Method</nt-wrapper></th>
<th><nt-wrapper translation-result="on">說明</nt-wrapper><nt-wrapper translation-origin="off">Description</nt-wrapper></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>static stringMatches(s: string &amp;verbar; Promise&lt;string&gt;, pattern: string &amp;verbar; RegExp): Promise&lt;boolean&gt;</code></td>
<td><nt-wrapper translation-result="on">按照 <code>string</code> 或 <code>RegExp</code> 型別的模式比較字串或字串的 <code>Promise</code>，並回傳一個表明它是否對應 <code>Promise</code></nt-wrapper><nt-wrapper translation-origin="off">Compares a string or <code>Promise</code> of a string against a <code>string</code> or <code>RegExp</code> and returns a boolean <code>Promise</code> indicating whether it matches.</nt-wrapper></td>
</tr>

<tr>
<td><code>addOption&lt;O&gt;(name: string, option: O &amp;verbar; undefined, predicate: (harness: T, option: O) =&gt; Promise&lt;boolean&gt;): HarnessPredicate&lt;T&gt;</code></td>
<td><nt-wrapper translation-result="on">建立一個新的 <code>HarnessPredicate</code> 來強制執行當前的所有條件，再加上 <code>predicate</code> 引數指定的新約束條件。如果 <code>option</code> 引數為 <code>undefined</code>，此 <code>predicate</code> 總是回傳 true。</nt-wrapper><nt-wrapper translation-origin="off">Creates a new <code>HarnessPredicate</code> that enforces all of the conditions of the current one, plus the new constraint specified by the <code>predicate</code> parameter. If the <code>option</code> parameter is <code>undefined</code> the <code>predicate</code> is considered to be always true.</nt-wrapper></td>
</tr>

<tr>
<td><code>add(description: string, predicate: (harness: T) =&gt; Promise&lt;boolean&gt;): HarnessPredicate&lt;T&gt;</code></td>
<td><nt-wrapper translation-result="on">建立一個新的 <code>HarnessPredicate</code> 來強制執行當前的所有條件，再加上 <code>predicate</code> 引數指定的新約束條件。</nt-wrapper><nt-wrapper translation-origin="off">Creates a new <code>HarnessPredicate</code> that enforces all of the conditions of the current one, plus the new constraint specified by the <code>predicate</code> parameter.</nt-wrapper></td>
</tr>

</tbody></table>
<p translation-result="on">例如，當使用選單時，根據觸發器文字新增一種過濾方式並根據文字來過濾選單項會很有用：</p><p translation-origin="off">For example, when working with a menu it would likely be useful to add a way to filter based on
trigger text and to filter menu items based on their text:</p>

<pre><code class="language-ts"><span class="hljs-keyword">interface</span> MyMenuHarnessFilters <span class="hljs-keyword">extends</span> BaseHarnessFilters {
  <span class="hljs-comment">/** Filters based on the trigger text for the menu. */</span>
  triggerText?: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">RegExp</span>;
}

<span class="hljs-keyword">interface</span> MyMenuItemHarnessFilters <span class="hljs-keyword">extends</span> BaseHarnessFilters {
  <span class="hljs-comment">/** Filters based on the text of the menu item. */</span>
  text?: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">RegExp</span>;
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMenuHarness</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ComponentHarness</span> </span>{
  <span class="hljs-keyword">static</span> hostSelector = <span class="hljs-string">'my-menu'</span>;

  <span class="hljs-comment">/** Creates a `HarnessPredicate` used to locate a particular `MyMenuHarness`. */</span>
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">with</span>(options: MyMenuHarnessFilters): HarnessPredicate&lt;MyMenuHarness&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HarnessPredicate(MyMenuHarness, options)
        .addOption(<span class="hljs-string">'trigger text'</span>, options.triggerText,
            <span class="hljs-function">(<span class="hljs-params">harness, text</span>) =&gt;</span> HarnessPredicate.stringMatches(harness.getTriggerText(), text));
  }

  <span class="hljs-keyword">protected</span> getPopupHarness = <span class="hljs-built_in">this</span>.locatorFor(MyPopupHarness);

  <span class="hljs-comment">/** Gets the text of the menu trigger. */</span>
  <span class="hljs-keyword">async</span> getTriggerText(): <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">string</span>&gt; {
    <span class="hljs-keyword">const</span> popupHarness = <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.getPopupHarness();
    <span class="hljs-keyword">return</span> popupHarness.getTriggerText();
  }

  ...
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMenuItemHarness</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ComponentHarness</span> </span>{
  <span class="hljs-keyword">static</span> hostSelector = <span class="hljs-string">'my-menu-item'</span>;

  <span class="hljs-comment">/** Creates a `HarnessPredicate` used to locate a particular `MyMenuItemHarness`. */</span>
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">with</span>(options: MyMenuItemHarnessFilters): HarnessPredicate&lt;MyMenuItemHarness&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HarnessPredicate(MyMenuItemHarness, options)
        .addOption(<span class="hljs-string">'text'</span>, options.text,
            <span class="hljs-function">(<span class="hljs-params">harness, text</span>) =&gt;</span> HarnessPredicate.stringMatches(harness.getText(), text));
  }

  <span class="hljs-comment">/** Gets the text of the menu item. */</span>
  <span class="hljs-keyword">async</span> getText(): <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">string</span>&gt; {
    <span class="hljs-keyword">const</span> host = <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.host();
    <span class="hljs-keyword">return</span> host.text();
  }
}
</code></pre>
<p translation-result="on">你可以用 <code>HarnessPredicate</code> 代替 <code>ComponentHarness</code> 傳給 <code>HarnessLoader</code>、<code>LocatorFactory</code> 或 <code>ComponentHarness</code> 上的任何 API。這樣，測試作者就可以在建立測試工具實例時輕鬆定位到特定的元件實例。它還能讓測試工具的作者利用同樣的 <code>HarnessPredicate</code>，在他們的測試工具類別上支援更強大的 API。例如前面看過的 <code>MyMenuHarness</code> 的 <code>getItems</code> 方法。現在可以很容易地擴充套件它以允許本測試工具的使用者搜尋特定的選單項：</p><p translation-origin="off">You can pass a <code>HarnessPredicate</code> in place of a <code>ComponentHarness</code> class to any of the APIs on
<code>HarnessLoader</code>, <code>LocatorFactory</code>, or <code>ComponentHarness</code>. This allows test authors to easily target
a particular component instance when creating a harness instance. It also allows the harness author
to leverage the same <code>HarnessPredicate</code> to enable more powerful APIs on their harness class. For
example, consider the <code>getItems</code> method on the <code>MyMenuHarness</code> shown above.
This can now easily be expanded to allow users of the harness to search for particular menu items:</p>

<pre><code class="language-ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMenuHarness</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ComponentHarness</span> </span>{
  <span class="hljs-keyword">static</span> hostSelector = <span class="hljs-string">'my-menu'</span>;

  <span class="hljs-comment">/** Gets a list of items in the menu, optionally filtered based on the given criteria. */</span>
  <span class="hljs-keyword">async</span> getItems(filters: MyMenuItemHarnessFilters = {}): <span class="hljs-built_in">Promise</span>&lt;MyMenuItemHarness[]&gt; {
    <span class="hljs-keyword">const</span> getFilteredItems = <span class="hljs-built_in">this</span>.locatorForAll(MyMenuItemHarness.with(filters));
    <span class="hljs-keyword">return</span> getFilteredItems();
  }

  ...
}
</code></pre>

        <h4 id="creating-a-harnessloader-for-an-element" class="docs-header-link" translation-result="on">
          <span header-link="為元素建立一個-harnessloader"></span>
          為元素建立一個 <code>HarnessLoader</code>
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="creating-a-harnessloader-for-an-element"></span>
          Creating a <code>HarnessLoader</code> for an element
        </h4>
      
        
      <p translation-result="on">有些元件會使用 <code>&lt;ng-content&gt;</code> 把其他內容投影到元件的樣板中。當為這樣的元件建立一個測試工具時，你可以給這個測試工具使用者提供一個 <code>&lt;ng-content&gt;</code> 容器範圍內的 <code>HarnessLoader</code> 實例。這可以讓測試工具的使用者能夠為任何作為內容傳進來的元件載入額外的測試工具。<code>ComponentHarness</code> 有幾個 API 可以用來為這種情況建立 <code>HarnessLoader</code> 實例。</p><p translation-origin="off">Some components use <code>&lt;ng-content&gt;</code> to project additional content into the component's template. When
creating a harness for such a component, you can give the harness user a <code>HarnessLoader</code> instance
scoped to the element containing the <code>&lt;ng-content&gt;</code>. This allows the user of the harness to load
additional harnesses for whatever components were passed in as content. <code>ComponentHarness</code> has
several APIs that can be used to create <code>HarnessLoader</code> instances for cases like this.</p>

<table>
<thead>
<tr>
<th><nt-wrapper translation-result="on">方法</nt-wrapper><nt-wrapper translation-origin="off">Method</nt-wrapper></th>
<th><nt-wrapper translation-result="on">說明</nt-wrapper><nt-wrapper translation-origin="off">Description</nt-wrapper></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>harnessLoaderFor(selector: string): Promise&lt;HarnessLoader&gt;</code></td>
<td><nt-wrapper translation-result="on">獲取一個 <code>Promise</code>，它解析為以指定的選擇器相對應的第一個元素為根的 <code>HarnessLoader</code>；如果沒有找到此元件，則 <code>Promise</code> 會拒絕。</nt-wrapper><nt-wrapper translation-origin="off">Gets a <code>Promise</code> for a <code>HarnessLoader</code> rooted at the first element matching the given selector, if no element is found the <code>Promise</code> rejects.</nt-wrapper></td>
</tr>

<tr>
<td><code>harnessLoaderForOptional(selector: string): Promise&lt;HarnessLoader &amp;verbar; null&gt;</code></td>
<td><nt-wrapper translation-result="on">獲取一個 <code>Promise</code>，它解析為與指定選擇器對應的第一個元素，如果沒有找到此元素，則 <code>Promise</code> 會解析為 <code>null</code>。</nt-wrapper><nt-wrapper translation-origin="off">Gets a <code>Promise</code> for a <code>HarnessLoader</code> rooted at the first element matching the given selector, if no element is found the <code>Promise</code> resolves to <code>null</code>.</nt-wrapper></td>
</tr>

<tr>
<td><code>harnessLoaderForAll(selector: string): Promise&lt;HarnessLoader[]&gt;</code></td>
<td><nt-wrapper translation-result="on">獲取一個 <code>Promise</code>，它是一個以和指定選擇器對應的每個元素為根的 <code>HarnessLoader</code> 清單</nt-wrapper><nt-wrapper translation-origin="off">Gets a <code>Promise</code> for a list of <code>HarnessLoader</code>, one rooted at each element matching the given selector.</nt-wrapper></td>
</tr>

</tbody></table>
<p translation-result="on">前面討論過的 <code>MyPopup</code> 元件就是一個很好的例子，它包含了一些使用者可能希望為其載入測試工具的內容。
<code>MyPopupHarness</code> 可以透過擴充套件 <code>ContentContainerComponentHarness</code> 來為此新增支援。</p><p translation-origin="off">The <code>MyPopup</code> component discussed earlier is a good example of a component with arbitrary content
that users may want to load harnesses for. <code>MyPopupHarness</code> could add support for this by
extending <code>ContentContainerComponentHarness</code>.</p>

<pre><code class="language-ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPopupHarness</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ContentContainerComponentHarness</span>&lt;<span class="hljs-title">string</span>&gt; </span>{
  <span class="hljs-keyword">static</span> hostSelector = <span class="hljs-string">'my-popup'</span>;
}
</code></pre>

        <h4 id="accessing-elements-outside-of-the-components-host-element" class="docs-header-link" translation-result="on">
          <span header-link="訪問該組件的宿主元素之外的元素"></span>
          訪問該組件的宿主元素之外的元素
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="accessing-elements-outside-of-the-components-host-element"></span>
          Accessing elements outside of the component's host element
        </h4>
      
        
      <p translation-result="on">有時元件工具可能需要訪問相應元件的宿主元素之外的元素。那些使用 <a href="https://material.angular.cn/cdk/overlay/overview">CDK 浮層</a>的元件就是這樣的例子。
元件的宿主元素外面的 CDK 浮層會建立一個直接附著在 body 上的元素。在這個例子中，<code>ComponentHarness</code> 提供了一個方法，可以用來獲取根元素的 <code>LocatorFactory</code>。
此 <code>LocatorFactory</code> 支援大多數與 <code>ComponentHarness</code> 基底類別相同的 API，然後可以用來相對於該文件的根元素進行查詢。</p><p translation-origin="off">There are times when a component harness might need to access elements outside of its corresponding
component's host element. Components that use <a href="https://material.angular.io/cdk/overlay/overview">CDK overlay</a> serve as examples of this. The CDK overlay creates an element that is attached directly to the body, outside of the component's host element. In this case,
<code>ComponentHarness</code> provides a method that can be used to get a <code>LocatorFactory</code> for the root element
of the document. The <code>LocatorFactory</code> supports most of the same APIs as the <code>ComponentHarness</code> base
class, and can then be used to query relative to the document's root element.</p>

<table>
<thead>
<tr>
<th><nt-wrapper translation-result="on">方法</nt-wrapper><nt-wrapper translation-origin="off">Method</nt-wrapper></th>
<th><nt-wrapper translation-result="on">說明</nt-wrapper><nt-wrapper translation-origin="off">Description</nt-wrapper></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>documentRootLocatorFactory(): LocatorFactory</code></td>
<td><nt-wrapper translation-result="on">建立一個以該文件的根元素為根的 <code>LocatorFactory</code>。</nt-wrapper><nt-wrapper translation-origin="off">Creates a <code>LocatorFactory</code> rooted at the document's root element.</nt-wrapper></td>
</tr>

</tbody></table>
<p translation-result="on">假設 <code>MyPopup</code> 元件使用了 CDK 浮層作為彈出內容，而不是它自己樣板中的一個元素。在這種情況下，<code>MyPopupHarness</code> 可能必須透過 <code>documentRootLocatorFactory()</code> 訪問其內容元素：</p><p translation-origin="off">Consider if the <code>MyPopup</code> component above used the CDK overlay for the popup content, rather than an
element in its own template. In this case, <code>MyPopupHarness</code> would have to access the content element
via <code>documentRootLocatorFactory()</code>:</p>

<pre><code class="language-ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPopupHarness</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ComponentHarness</span> </span>{
  <span class="hljs-keyword">static</span> hostSelector = <span class="hljs-string">'my-popup'</span>;

  <span class="hljs-comment">/** Gets a `HarnessLoader` whose root element is the popup's content element. */</span>
  <span class="hljs-keyword">async</span> getHarnessLoaderForContent(): <span class="hljs-built_in">Promise</span>&lt;HarnessLoader&gt; {
    <span class="hljs-keyword">const</span> rootLocator = <span class="hljs-built_in">this</span>.documentRootLocatorFactory();
    <span class="hljs-keyword">return</span> rootLocator.harnessLoaderFor(<span class="hljs-string">'my-popup-content'</span>);
  }
}
</code></pre>

        <h4 id="waiting-for-asynchronous-tasks" class="docs-header-link" translation-result="on">
          <span header-link="等待非同步任務"></span>
          等待非同步任務
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="waiting-for-asynchronous-tasks"></span>
          Waiting for asynchronous tasks
        </h4>
      
        
      <p translation-result="on"><code>TestElement</code> 上的方法會自動觸發 Angular 的變更檢測，並等待 <code>NgZone</code> 中的任務，所以在大多數情況下，這些方法不需要特別的工作來讓執行緒作者等待非同步任務。
然而，在一些邊緣情況下這可能還不夠。</p><p translation-origin="off">The methods on <code>TestElement</code> automatically trigger Angular's change detection and wait for tasks
inside the <code>NgZone</code>, so in most cases no special effort is required for harness authors to wait on
asynchronous tasks. However, there are some edge cases where this may not be sufficient.</p>

<p translation-result="on">在某些情況下，在完全重新整理動畫事件之前，Angular 動畫可能還需要第二個變更檢測迴圈和等待 <code>NgZone</code> 進入穩定狀態。
如果需要這樣做，<code>ComponentHarness</code> 提供了一個 <code>forceStabilize()</code> 方法，可以呼叫它來進行第二輪測試。</p><p translation-origin="off">Under some circumstances, Angular animations may require a second cycle of change detection and
subsequent <code>NgZone</code> stabilization before animation events are fully flushed. In cases where this is
needed, the <code>ComponentHarness</code> offers a <code>forceStabilize()</code> method that can be called to do the
second round.</p>

<p translation-result="on">另外，某些元件可能會故意在 <code>NgZone</code> <em>之外</em>安排任務，這通常是使用 <code>NgZone.runOutsideAngular</code> 完成的。
在這種情況下，對應的測試工具可能需要顯式等待 <code>NgZone</code> 以外的任務，因為這不會自動發生。
<code>ComponentHarness</code> 為此提供了一個名為 <code>waitForTasksOutsideAngular</code> 的方法。</p><p translation-origin="off">Additionally, some components may intentionally schedule tasks <em>outside</em> of <code>NgZone</code>, this is
typically accomplished by using <code>NgZone.runOutsideAngular</code>. In this case, the corresponding harness
may need to explicitly wait for tasks outside <code>NgZone</code>, as this does not happen automatically.
<code>ComponentHarness</code> offers a method called <code>waitForTasksOutsideAngular</code> for this purpose.</p>

<table>
<thead>
<tr>
<th><nt-wrapper translation-result="on">方法</nt-wrapper><nt-wrapper translation-origin="off">Method</nt-wrapper></th>
<th><nt-wrapper translation-result="on">說明</nt-wrapper><nt-wrapper translation-origin="off">Description</nt-wrapper></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>forceStabilize(): Promise&lt;void&gt;</code></td>
<td><nt-wrapper translation-result="on">在 Angular 中顯式執行一輪變更檢測，並等待 <code>NgZone</code> 穩定下來。</nt-wrapper><nt-wrapper translation-origin="off">Explicitly runs a round of change detection in Angular and waits for <code>NgZone</code> to stabilize.</nt-wrapper></td>
</tr>

<tr>
<td><code>waitForTasksOutsideAngular(): Promise&lt;void&gt;</code></td>
<td><nt-wrapper translation-result="on">等待 <code>NgZone</code> 以外的任務完成。</nt-wrapper><nt-wrapper translation-origin="off">Waits for tasks scheduled outside of <code>NgZone</code> to complete.</nt-wrapper></td>
</tr>

</tbody></table>

        <h3 id="api-for-harness-environment-authors" class="docs-header-link" translation-result="on">
          <span header-link="測試工具環境作者的-api"></span>
          測試工具環境作者的 API
        </h3><h3 class="docs-header-link" translation-origin="off">
          <span header-link="api-for-harness-environment-authors"></span>
          API for harness environment authors
        </h3>
      
        
      <p translation-result="on">測試工具環境作者是那些希望在其他測試環境中增加使用元件測試工具支援的開發人員。開箱即用的 Angular CDK 元件測試工具可用於 Selenium WebDriver E2E 測試和 Karma 單元測試。開發人員可以建立 <code>TestElement</code> 和 <code>HarnessEnvironment</code> 的自定義實現來支援更多環境。</p><p translation-origin="off">Harness environment authors are developers who want to add support for using component harnesses in
additional testing environments. Out-of-the-box, Angular CDK's component harnesses can be used in
Selenium WebDriver E2E tests and Karma unit tests. Developers can support additional environments by
creating custom implementations of <code>TestElement</code> and <code>HarnessEnvironment</code>.</p>


        <h4 id="creating-a-testelement-implementation-for-the-environment" class="docs-header-link" translation-result="on">
          <span header-link="為此環境建立一個-testelement"></span>
          為此環境建立一個 <code>TestElement</code>
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="creating-a-testelement-implementation-for-the-environment"></span>
          Creating a <code>TestElement</code> implementation for the environment
        </h4>
      
        
      <p translation-result="on">新增對新測試環境的支援的第一步是建立一個 <code>TestElement</code> 實現。<code>TestElement</code> 介面用作 DOM 元素的環境無關表示形式。它能讓測試工具與 DOM 元素進行互動，而不用管底層環境如何。由於某些環境不支援與 DOM 元素的同步互動（比如 webdriver），因此所有的 <code>TestElement</code> 方法都是非同步的，回傳一個包含該操作結果的 <code>Promise</code></p><p translation-origin="off">The first step in adding support for a new testing environment is to create a <code>TestElement</code>
implementation. The <code>TestElement</code> interface serves as an environment-agnostic representation of a
DOM element; it lets harnesses interact with DOM elements regardless of the underlying environment.
Because some environments don't support interacting with DOM elements synchronously
(e.g. WebDriver), all of the <code>TestElement</code> methods are asynchronous, returning a <code>Promise</code> with the
result of the operation.</p>

<table>
<thead>
<tr>
<th><nt-wrapper translation-result="on">方法</nt-wrapper><nt-wrapper translation-origin="off">Method</nt-wrapper></th>
<th><nt-wrapper translation-result="on">說明</nt-wrapper><nt-wrapper translation-origin="off">Description</nt-wrapper></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>blur(): Promise&lt;void&gt;</code></td>
<td><nt-wrapper translation-result="on">讓此元素失焦。</nt-wrapper><nt-wrapper translation-origin="off">Blurs the element.</nt-wrapper></td>
</tr>

<tr>
<td><code>clear(): Promise&lt;void&gt;</code></td>
<td><nt-wrapper translation-result="on">從此元素中清除文字（僅適用於 <code>&lt;input&gt;</code> 和 <code>&lt;textarea&gt;</code> ）。</nt-wrapper><nt-wrapper translation-origin="off">Clears the text from an element (only applies for <code>&lt;input&gt;</code> and <code>&lt;textarea&gt;</code>).</nt-wrapper></td>
</tr>

<tr>
<td><code>click(relativeX?: number, relativeY?: number): Promise&lt;void&gt;</code></td>
<td><nt-wrapper translation-result="on">在相對於它左上角的坐標點選此元素。</nt-wrapper><nt-wrapper translation-origin="off">Clicks an element at a point relative to it's top-left corner.</nt-wrapper></td>
</tr>

<tr>
<td><code>focus(): Promise&lt;void&gt;</code></td>
<td><nt-wrapper translation-result="on">讓此元素獲得焦點。</nt-wrapper><nt-wrapper translation-origin="off">Focuses the element.</nt-wrapper></td>
</tr>

<tr>
<td><code>getCssValue(property: string): Promise&lt;string&gt;</code></td>
<td><nt-wrapper translation-result="on">獲取此元素指定屬性的計算 CSS 值。</nt-wrapper><nt-wrapper translation-origin="off">Gets the computed CSS value of the given property for the element.</nt-wrapper></td>
</tr>

<tr>
<td><code>hover(): Promise&lt;void&gt;</code></td>
<td><nt-wrapper translation-result="on">將滑鼠懸停在此元素上方。</nt-wrapper><nt-wrapper translation-origin="off">Hovers the mouse over the element.</nt-wrapper></td>
</tr>

<tr>
<td><code>sendKeys(...keys: (string &amp;verbar; TestKey)[]): Promise&lt;void&gt;</code></td>
<td><nt-wrapper translation-result="on">向此元素傳送一系列按鍵事件。</nt-wrapper><nt-wrapper translation-origin="off">Sends a sequence of key events to the element.</nt-wrapper></td>
</tr>

<tr>
<td><code>sendKeys(modifiers: ModifierKeys, ...keys: (string &amp;verbar; TestKey)[]): Promise&lt;void&gt;</code></td>
<td><nt-wrapper translation-result="on">把一系列按鍵事件傳送給此元素，同時按住一組修飾鍵。</nt-wrapper><nt-wrapper translation-origin="off">Sends a sequence of key events to the element, while holding a set of modifier keys.</nt-wrapper></td>
</tr>

<tr>
<td><code>text(): Promise&lt;string&gt;</code></td>
<td><nt-wrapper translation-result="on">獲取此元素的文字內容。</nt-wrapper><nt-wrapper translation-origin="off">Gets the text content of the element.</nt-wrapper></td>
</tr>

<tr>
<td><code>getAttribute(name: string): Promise&lt;string &amp;verbar; null&gt;</code></td>
<td><nt-wrapper translation-result="on">從此元素獲取指定 HTML 屬性的值。</nt-wrapper><nt-wrapper translation-origin="off">Gets the value of the given HTML attribute for the element.</nt-wrapper></td>
</tr>

<tr>
<td><code>hasClass(name: string): Promise&lt;boolean&gt;</code></td>
<td><nt-wrapper translation-result="on">檢查此元素是否具有指定的類。</nt-wrapper><nt-wrapper translation-origin="off">Checks whether the element has the given class.</nt-wrapper></td>
</tr>

<tr>
<td><code>getDimensions(): Promise&lt;ElementDimensions&gt;</code></td>
<td><nt-wrapper translation-result="on">獲取此元素的尺寸。</nt-wrapper><nt-wrapper translation-origin="off">Gets the dimensions of the element.</nt-wrapper></td>
</tr>

<tr>
<td><code>getProperty(name: string): Promise&lt;any&gt;</code></td>
<td><nt-wrapper translation-result="on">從此元素獲取指定屬性的值。</nt-wrapper><nt-wrapper translation-origin="off">Gets the value of the given property for the element.</nt-wrapper></td>
</tr>

<tr>
<td><code>matchesSelector(selector: string): Promise&lt;boolean&gt;</code></td>
<td><nt-wrapper translation-result="on">檢查指定的選擇器是否與此元素對應。</nt-wrapper><nt-wrapper translation-origin="off">Checks whether the given selector matches the element.</nt-wrapper></td>
</tr>

<tr>
<td><code>setInputValue(value: string): Promise&lt;void&gt;;</code></td>
<td><nt-wrapper translation-result="on">設定輸入框的值。</nt-wrapper><nt-wrapper translation-origin="off">Sets the value of a property of an input.</nt-wrapper></td>
</tr>

<tr>
<td><code>selectOptions(...optionIndexes: number[]): Promise&lt;void&gt;;</code></td>
<td><nt-wrapper translation-result="on">選擇原生 <code>select</code> 元素中指定索引處的候選項。</nt-wrapper><nt-wrapper translation-origin="off">Selects the options at the specified indexes inside of a native <code>select</code> element.</nt-wrapper></td>
</tr>

<tr>
<td><code>dispatchEvent(name: string, data?: Record&lt;string, EventData&gt;): Promise&lt;void&gt;;</code></td>
<td><nt-wrapper translation-result="on">派發具有特定名稱的事件。</nt-wrapper><nt-wrapper translation-origin="off">Dispatches an event with a particular name.</nt-wrapper></td>
</tr>

</tbody></table>
<p translation-result="on"><code>TestElement</code> 介面包含類似 <code>HTMLElement</code> 方法的大部分方法。在大多數測試環境中都存在類似的方法，這使得實現這些方法相當簡單。使用 <code>sendKeys</code> 方法時要注意的一個重要區別是，<code>TestKey</code> 列舉中的鍵碼可能與測試環境中使用的鍵碼有所不同。環境作者應該堅持從 <code>TestKey</code> 程式碼對映到特定測試環境中的程式碼。</p><p translation-origin="off">The <code>TestElement</code> interface consists largely of methods that resemble methods
available on <code>HTMLElement</code>; similar methods exist in most test environments, which makes
implementing the methods fairly straightforward. However, one important difference to note when
implementing the <code>sendKeys</code> method, is that the key codes in the <code>TestKey</code>
enum likely differ from the key codes used in the test environment. Environment authors should
maintain a mapping from <code>TestKey</code> codes to the codes used in the particular testing environment.</p>

<p translation-result="on">Angular CDK 中的 <a href="https://github.com/angular/components/blob/main/src/cdk/testing/testbed/unit-test-element.ts#L57"><code>UnitTestElement</code></a> 和 <a href="https://github.com/angular/components/blob/main/src/cdk/testing/selenium-webdriver/selenium-web-driver-element.ts#L22"><code>SeleniumWebDriverElement</code></a> 實現就是實現這個介面的好例子。</p><p translation-origin="off">The
<a href="https://github.com/angular/components/blob/main/src/cdk/testing/testbed/unit-test-element.ts#L57"><code>UnitTestElement</code></a>
and
<a href="https://github.com/angular/components/blob/main/src/cdk/testing/selenium-webdriver/selenium-web-driver-element.ts#L22"><code>SeleniumWebDriverElement</code></a>
implementations in Angular CDK serve as good examples of implementations of this interface.</p>


        <h4 id="creating-a-harnessenvironment-implementation-for-the-environment" class="docs-header-link" translation-result="on">
          <span header-link="為此環境建立一個-harnessenvironment"></span>
          為此環境建立一個 <code>HarnessEnvironment</code>
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="creating-a-harnessenvironment-implementation-for-the-environment"></span>
          Creating a <code>HarnessEnvironment</code> implementation for the environment
        </h4>
      
        
      <p translation-result="on">測試作者使用 <code>HarnessEnvironemnt</code> 來建立用於測試的元件工具實例。</p><p translation-origin="off">Test authors use <code>HarnessEnvironment</code> to create component harness instances for use in tests.</p>

<p translation-result="on"><code>HarnessEnvironment</code> 是一個抽象類別，必須進行擴充套件才能為新環境建立一個具體的子類別。在支援新的測試環境時，你必須建立一個 <code>HarnessEnvironment</code> 子類別，為所有抽象成員新增具體的實現。</p><p translation-origin="off"><code>HarnessEnvironment</code> is an abstract class that must be extended to create a concrete subclass for
the new environment. When supporting a new test environment, you must create a <code>HarnessEnvironment</code>
subclass that adds concrete implementations for all abstract members.</p>

<p translation-result="on">你會發現 <code>HarnessEnvironment</code> 有一個泛型型別引數：<code>HarnessEnvironment&lt;E&gt;</code>。這個引數 <code>E</code> 就表示環境的原始元素型別。例如，這個引數在單元測試環境下是 <code>Element</code>。</p><p translation-origin="off">You will notice that <code>HarnessEnvironment</code> has a generic type parameter: <code>HarnessEnvironment&lt;E&gt;</code>.
This parameter, <code>E</code>, represents the raw element type of the environment. For example, this parameter
is <code>Element</code> for unit test environments.</p>

<p translation-result="on">下面是必須要實現的抽象方法：</p><p translation-origin="off">The following are the abstract methods that must be implemented:</p>

<table>
<thead>
<tr>
<th><nt-wrapper translation-result="on">方法</nt-wrapper><nt-wrapper translation-origin="off">Method</nt-wrapper></th>
<th><nt-wrapper translation-result="on">說明</nt-wrapper><nt-wrapper translation-origin="off">Description</nt-wrapper></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>abstract getDocumentRoot(): E</code></td>
<td><nt-wrapper translation-result="on">獲取此環境的根元素（例如 <code>document.body</code> ）。</nt-wrapper><nt-wrapper translation-origin="off">Gets the root element for the environment (e.g. <code>document.body</code>).</nt-wrapper></td>
</tr>

<tr>
<td><code>abstract createTestElement(element: E): TestElement</code></td>
<td><nt-wrapper translation-result="on">為指定的原始元素建立一個 <code>TestElement</code></nt-wrapper><nt-wrapper translation-origin="off">Creates a <code>TestElement</code> for the given raw element.</nt-wrapper></td>
</tr>

<tr>
<td><code>abstract createEnvironment(element: E): HarnessEnvironment</code></td>
<td><nt-wrapper translation-result="on">根據指定的原始元素建立一個 <code>HarnessEnvironment</code></nt-wrapper><nt-wrapper translation-origin="off">Creates a <code>HarnessEnvironment</code> rooted at the given raw element.</nt-wrapper></td>
</tr>

<tr>
<td><code>abstract getAllRawElements(selector: string): Promise&lt;E[]&gt;</code></td>
<td><nt-wrapper translation-result="on">獲取環境根元素下的所有與指定選擇器對應的原始元素。</nt-wrapper><nt-wrapper translation-origin="off">Gets all of the raw elements under the root element of the environment matching the given selector.</nt-wrapper></td>
</tr>

<tr>
<td><code>abstract forceStabilize(): Promise&lt;void&gt;</code></td>
<td><nt-wrapper translation-result="on">獲取一個當 <code>NgZone</code> 穩定時解析的 <code>Promise</code>。另外，只要可能，就告訴 <code>NgZone</code> 變穩定（比如在 <code>fakeAsync</code> 測試中的 <code>flush()</code></nt-wrapper><nt-wrapper translation-origin="off">Gets a <code>Promise</code> that resolves when the <code>NgZone</code> is stable. Additionally, if applicable, tells <code>NgZone</code> to stabilize (e.g. calling <code>flush()</code> in a <code>fakeAsync</code> test).</nt-wrapper></td>
</tr>

<tr>
<td><code>abstract waitForTasksOutsideAngular(): Promise&lt;void&gt;</code></td>
<td><nt-wrapper translation-result="on">獲取一個 <code>Promise</code>，它會在 <code>NgZone</code> 的父區域穩定時解析。</nt-wrapper><nt-wrapper translation-origin="off">Gets a <code>Promise</code> that resolves when the parent zone of <code>NgZone</code> is stable.</nt-wrapper></td>
</tr>

</tbody></table>
<p translation-result="on">除了實現所缺的方法之外，這個類還應該為測試作者提供一種獲取 <code>ComponentHarness</code> 實例的方法。
推薦的方法是具有一個受保護的建構式函式，並提供一個名為 <code>loader</code> 的靜態方法來回傳一個 <code>HarnessLoader</code> 的實例。這讓測試作者可以編寫如下程式碼：<code>SomeHarnessEnvironment.loader().getHarness(...)</code>。根據特定環境的需要，該類別可以提供幾種不同的靜態方法，或者要求傳遞引數。（例如，<code>TestbedHarnessEnvironment</code> 的 <code>loader</code> 方法接受了一個 <code>ComponentFixture</code>，該類別還提供了另外一些名為 <code>documentRootLoader</code> 和 <code>harnessForFixture</code> 靜態方法）。</p><p translation-origin="off">In addition to implementing the missing methods, this class should provide a way for test authors to
get <code>ComponentHarness</code> instances. The recommended approach is to have a protected constructor and
provide a static method called <code>loader</code> that returns a <code>HarnessLoader</code> instance. This allows test
authors to write code like: <code>SomeHarnessEnvironment.loader().getHarness(...)</code>. Depending on the
needs of the particular environment, the class may provide several different static methods or
require arguments to be passed. (e.g. the <code>loader</code> method on <code>TestbedHarnessEnvironment</code> takes a
<code>ComponentFixture</code>, and the class provides additional static methods called <code>documentRootLoader</code> and
<code>harnessForFixture</code>).</p>

<p translation-result="on">Angular CDK 中的 <a href="https://github.com/angular/components/blob/main/src/cdk/testing/testbed/testbed-harness-environment.ts#L20"><code>TestbedHarnessEnvironment</code></a> 和 <a href="https://github.com/angular/components/blob/main/src/cdk/testing/selenium-webdriver/selenium-web-driver-harness-environment.ts#L71"><code>SeleniumWebDriverHarnessEnvironment</code></a> 的實現就是很好的例子。</p><p translation-origin="off">The
<a href="https://github.com/angular/components/blob/main/src/cdk/testing/testbed/testbed-harness-environment.ts#L20"><code>TestbedHarnessEnvironment</code></a>
and
<a href="https://github.com/angular/components/blob/main/src/cdk/testing/selenium-webdriver/selenium-web-driver-harness-environment.ts#L71"><code>SeleniumWebDriverHarnessEnvironment</code></a>
implementations in Angular CDK serve as good examples of implementations of this interface.</p>


        <h4 id="handling-auto-change-detection-status" class="docs-header-link" translation-result="on">
          <span header-link="處理自動變更檢測狀態"></span>
          處理自動變更檢測狀態
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="handling-auto-change-detection-status"></span>
          Handling auto change detection status
        </h4>
      
        
      <p translation-result="on">為了支援 <code>manualChangeDetection</code> 和 <code>parallel</code> API，你的環境應該為自動變更檢測狀態安裝一個處理器。</p><p translation-origin="off">In order to support the <code>manualChangeDetection</code> and <code>parallel</code> APIs, your environment should install
a handler for the auto change detection status.</p>

<p translation-result="on">當你的環境想要開始處理自動變更檢測的狀態時，可以呼叫 <code>handleAutoChangeDetectionStatus(handler)</code>。此處理器函式會要求一個 <code>AutoChangeDetectionStatus</code> 引數，其中有兩個屬性：</p><p translation-origin="off">When your environment wants to start handling the auto change detection status it can call
<code>handleAutoChangeDetectionStatus(handler)</code>. The handler function will receive a 
<code>AutoChangeDetectionStatus</code> which has two properties:</p>

<ul>
<li><p translation-result="on"><code>isDisabled: boolean</code> - 表示當前是否停用了自動檢測。當為 true 時，你的環境的 <code>forceStabilize</code> 方法應該什麼也不做。這樣，使用者就可以手動觸發變更檢測。</p><p translation-origin="off"><code>isDisabled: boolean</code> - Indicates whether auto change detection is currently disabled. When true,
your environment's <code>forceStabilize</code> method should act as a no-op. This allows users to trigger
change detection manually instead.</p>

</li>
<li><p translation-result="on"><code>onDetectChangesNow?: () =&gt; void</code> - 如果指定了這個可選的回呼函式，你的環境應立即觸發變更檢測，並在變更檢測完成時調用該回調函式。</p><p translation-origin="off"><code>onDetectChangesNow?: () =&gt; void</code> - If this optional callback is specified, your environment
should trigger change detection immediately and call the callback when change detection finishes.</p>

</li>
</ul>
<p translation-result="on">如果你的環境要停止處理自動變更檢測的狀態，可以呼叫 <code>stopHandlingAutoChangeDetectionStatus()</code>。</p><p translation-origin="off">If your environment wants to stop handling auto change detection status it can call
<code>stopHandlingAutoChangeDetectionStatus()</code>.</p>

</div>