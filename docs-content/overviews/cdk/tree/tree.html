<div class="docs-markdown"><p translation-result="on"><code>&lt;cdk-tree&gt;</code> 讓開發人員能夠為結構化資料建立自定義的樹型體驗。<code>&lt;cdk-tree&gt;</code> 為建立其它屬性提供了基礎，比如對樹進行過濾。對於 Material Design 風格的樹，參見基於 <code>&lt;cdk-tree&gt;</code> 建立的 <code>&lt;mat-tree&gt;</code>。</p><p translation-origin="off">The <code>&lt;cdk-tree&gt;</code> enables developers to build a customized tree experience for structured data. The
<code>&lt;cdk-tree&gt;</code> provides a foundation to build other features such as filtering on top of tree.
For a Material Design styled tree, see <code>&lt;mat-tree&gt;</code> which builds on top of the <code>&lt;cdk-tree&gt;</code>.</p>

<p translation-result="on">樹有兩種型別：扁平樹和巢狀樹。這兩種樹的 DOM 結構是不同的。</p><p translation-origin="off">There are two types of trees: flat tree and nested Tree. The DOM structures are different for
these two types of trees.</p>


        <h4 id="flat-tree" class="docs-header-link" translation-result="on">
          <span header-link="扁平樹"></span>
          扁平樹
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="flat-tree"></span>
          Flat tree
        </h4>
      
        
      <div material-docs-example="cdk-tree-flat"></div>

<p translation-result="on">在扁平樹中，其層次結構是扁平的，這些節點並沒有渲染在其它節點內部，而是依次渲染兄弟節點。<code>TreeFlattener</code> 的實例用於從帶層次結構的資料中生成一個扁平的條目清單。每個樹節點的『級別』都是透過 <code>getLevel</code> 方法讀取的。這種級別可用來為節點設定樣式，以便讓其顯示出有合適的縮排級別。</p><p translation-origin="off">In a flat tree, the hierarchy is flattened; nodes are not rendered inside of each other, but instead
are rendered as siblings in sequence. An instance of <code>TreeFlattener</code> is used to generate the flat
list of items from hierarchical data. The "level" of each tree node is read through the <code>getLevel</code>
method of the <code>TreeControl</code>; this level can be used to style the node such that it is indented to
the appropriate level.</p>

<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">cdk-tree</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">cdk-tree-node</span>&gt;</span> parent node <span class="hljs-tag">&lt;/<span class="hljs-name">cdk-tree-node</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">cdk-tree-node</span>&gt;</span> -- child node1 <span class="hljs-tag">&lt;/<span class="hljs-name">cdk-tree-node</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">cdk-tree-node</span>&gt;</span> -- child node2 <span class="hljs-tag">&lt;/<span class="hljs-name">cdk-tree-node</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">cdk-tree</span>&gt;</span>
</code></pre>
<p translation-result="on">扁平的樹通常更容易設定樣式和進行探查。它們對各種捲動（如無限捲動或虛擬捲動）也更友好。</p><p translation-origin="off">Flat trees are generally easier to style and inspect. They are also more friendly to scrolling
variations, such as infinite or virtual scrolling.</p>


        <h4 id="nested-tree" class="docs-header-link" translation-result="on">
          <span header-link="巢狀的樹"></span>
          巢狀的樹
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="nested-tree"></span>
          Nested tree
        </h4>
      
        
      <div material-docs-example="cdk-tree-nested"></div>

<p translation-result="on">對於巢狀樹，在 DOM 樹中的子節點會放在父節點內部。父節點包含一個用於投射（project）子節點內容的節點出口。</p><p translation-origin="off">In nested tree, children nodes are placed inside their parent node in DOM. The parent node contains
a node outlet into which children are projected.</p>

<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">cdk-tree</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">cdk-nested-tree-node</span>&gt;</span>
    parent node
    <span class="hljs-tag">&lt;<span class="hljs-name">cdk-nested-tree-node</span>&gt;</span> -- child node1 <span class="hljs-tag">&lt;/<span class="hljs-name">cdk-nested-tree-node</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">cdk-nested-tree-node</span>&gt;</span> -- child node2 <span class="hljs-tag">&lt;/<span class="hljs-name">cdk-nested-tree-node</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">cdk-nested-tree-node</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">cdk-tree</span>&gt;</span>
</code></pre>
<p translation-result="on">當需要以可視的方式來表示層次關係時，用巢狀樹會比用扁平樹更容易。</p><p translation-origin="off">Nested trees are easier to work with when hierarchical relationships are visually represented in
ways that would be difficult to accomplish with flat nodes.</p>


        <h3 id="using-the-cdk-tree" class="docs-header-link" translation-result="on">
          <span header-link="使用-cdk-樹"></span>
          使用 CDK 樹
        </h3><h3 class="docs-header-link" translation-origin="off">
          <span header-link="using-the-cdk-tree"></span>
          Using the CDK tree
        </h3>
      
        
      
        <h4 id="writing-your-tree-template" class="docs-header-link" translation-result="on">
          <span header-link="編寫你的樹樣板"></span>
          編寫你的樹樣板
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="writing-your-tree-template"></span>
          Writing your tree template
        </h4>
      
        
      <p translation-result="on">唯一需要定義的是樹節點樣板。有兩種型別的樹節點，對於扁平樹有 <code>&lt;cdk-tree-node&gt;</code>，對於巢狀樹有 <code>&lt;cdk-tree-nested-node&gt;</code>。樹節點的樣板定義了樹節點的外觀、展開/摺疊控制元件以及用來巢狀子節點的結構。</p><p translation-origin="off">The only thing you need to define is the tree node template. There are two types of tree nodes,
<code>&lt;cdk-tree-node&gt;</code> for flat tree and <code>&lt;cdk-tree-nested-node&gt;</code> for nested tree. The tree node
template defines the look of the tree node, expansion/collapsing control and the structure for
nested children nodes.</p>

<p translation-result="on">任何帶 <code>cdkNodeDef</code> 的元素都會指定一個節點定義。該指令會匯出要在節點樣板中的各個繫結所需的節點數據。</p><p translation-origin="off">A node definition is specified via any element with <code>cdkNodeDef</code>. This directive exports the node
data to be used in any bindings in the node template.</p>

<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">cdk-tree-node</span> *<span class="hljs-attr">cdkNodeDef</span>=<span class="hljs-string">"let node"</span>&gt;</span>
  {{node.key}}: {{node.value}}
<span class="hljs-tag">&lt;/<span class="hljs-name">cdk-tree-node</span>&gt;</span>
</code></pre>

        <h5 id="flat-tree-node-template" class="docs-header-link" translation-result="on">
          <span header-link="扁平樹節點樣板"></span>
          扁平樹節點樣板
        </h5><h5 class="docs-header-link" translation-origin="off">
          <span header-link="flat-tree-node-template"></span>
          Flat tree node template
        </h5>
      
        
      <p translation-result="on">扁平樹使用每個節點的 <code>level</code> 來渲染節點的層次結構。指定節點的『縮排（indent）』是透過根據每個節點的級別為其增加間距來完成的。可以透過應用 <code>cdkNodePadding</code> 指令或自定義樣式來新增間距。</p><p translation-origin="off">Flat tree uses each node's <code>level</code> to render the hierarchy of the nodes.
The "indent" for a given node is accomplished by adding spacing to each node based on its level.
Spacing can be added either by applying the <code>cdkNodePadding</code> directive or by applying custom styles.</p>


        <h5 id="nested-tree-node-template" class="docs-header-link" translation-result="on">
          <span header-link="巢狀樹節點樣板"></span>
          巢狀樹節點樣板
        </h5><h5 class="docs-header-link" translation-origin="off">
          <span header-link="nested-tree-node-template"></span>
          Nested tree node template
        </h5>
      
        
      <p translation-result="on">當使用巢狀樹節點時，該節點樣板中必須包含一個 <code>cdkTreeNodeOutlet</code>，用於標記該節點的子節點要渲染到的位置。</p><p translation-origin="off">When using nested tree nodes, the node template must contain a <code>cdkTreeNodeOutlet</code>, which marks
where the children of the node will be rendered.</p>

<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">cdk-nested-tree-node</span> *<span class="hljs-attr">cdkNodeDef</span>=<span class="hljs-string">"let node"</span>&gt;</span>
  {{node.value}}
  <span class="hljs-tag">&lt;<span class="hljs-name">ng-container</span> <span class="hljs-attr">cdkTreeNodeOutlet</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ng-container</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">cdk-nested-tree-node</span>&gt;</span>
</code></pre>

        <h4 id="adding-expandcollapse" class="docs-header-link" translation-result="on">
          <span header-link="新增展開摺疊器"></span>
          新增展開/摺疊器
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="adding-expandcollapse"></span>
          Adding expand/collapse
        </h4>
      
        
      <p translation-result="on">可以在這個樹節點樣板中新增 <code>cdkTreeNodeToggle</code> 來展開/摺疊此節點。這個切換開關切換了 TreeControl 的 <code>expand</code>/<code>collapse</code> 函式，還可以把 <code>[cdkTreeNodeToggleRecursive]</code> 設定為 <code>true</code> 來遞迴展開/摺疊某個樹節點。</p><p translation-origin="off">A <code>cdkTreeNodeToggle</code> can be added in the tree node template to expand/collapse the tree node.
The toggle toggles the expand/collapse functions in TreeControl and is able to expand/collapse
a tree node recursively by setting <code>[cdkTreeNodeToggleRecursive]</code> to true.</p>

<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">cdk-tree-node</span> *<span class="hljs-attr">cdkNodeDef</span>=<span class="hljs-string">"let node"</span> <span class="hljs-attr">cdkTreeNodeToggle</span> [<span class="hljs-attr">cdkTreeNodeToggleRecursive</span>]=<span class="hljs-string">"true"</span>&gt;</span>
    {{node.value}}
<span class="hljs-tag">&lt;/<span class="hljs-name">cdk-tree-node</span>&gt;</span>
</code></pre>
<p translation-result="on">這個切換開關可以放在樹節點中的任意位置，而且只能透過點選動作進行切換。為了獲得最佳的無障礙性，<code>cdkTreeNodeToggle</code> 應該放在一個 button 元素上，並擁有一個合適的 <code>aria-label</code>。</p><p translation-origin="off">The toggle can be placed anywhere in the tree node, and is only toggled by click action.
For best accessibility, <code>cdkTreeNodeToggle</code> should be on a button element and have an appropriate
<code>aria-label</code>.</p>

<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">cdk-tree-node</span> *<span class="hljs-attr">cdkNodeDef</span>=<span class="hljs-string">"let node"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">cdkTreeNodeToggle</span> <span class="hljs-attr">aria-label</span>=<span class="hljs-string">"toggle tree node"</span> [<span class="hljs-attr">cdkTreeNodeToggleRecursive</span>]=<span class="hljs-string">"true"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mat-icon</span>&gt;</span>expand<span class="hljs-tag">&lt;/<span class="hljs-name">mat-icon</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
  {{node.value}}
<span class="hljs-tag">&lt;/<span class="hljs-name">cdk-tree-node</span>&gt;</span>
</code></pre>

        <h4 id="padding-flat-tree-only" class="docs-header-link" translation-result="on">
          <span header-link="襯距（僅限扁平樹）"></span>
          襯距（僅限扁平樹）
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="padding-flat-tree-only"></span>
          Padding (Flat tree only)
        </h4>
      
        
      <p translation-result="on"><code>cdkTreeNodePadding</code> 可以放在扁平樹的節點樣板中，以顯示扁平樹節點的級別訊息。</p><p translation-origin="off">The cdkTreeNodePadding can be placed in a flat tree's node template to display the level
information of a flat tree node.</p>

<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">cdk-tree-node</span> *<span class="hljs-attr">cdkNodeDef</span>=<span class="hljs-string">"let node"</span> <span class="hljs-attr">cdkNodePadding</span>&gt;</span>
  {{node.value}}
<span class="hljs-tag">&lt;/<span class="hljs-name">cdk-tree-node</span>&gt;</span>
</code></pre>
<p translation-result="on">巢狀樹不需要這種襯距，因為 <code>padding</code> 可以很容易地新增到 DOM 中的層次結構上。</p><p translation-origin="off">Nested tree does not need this padding since padding can be easily added to the hierarchy structure
in DOM.</p>


        <h4 id="conditional-template" class="docs-header-link" translation-result="on">
          <span header-link="條件樣板"></span>
          條件樣板
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="conditional-template"></span>
          Conditional template
        </h4>
      
        
      <p translation-result="on">樹可以包括多個節點樣板，並透過樣板的 <code>when</code> 謂詞為特定的資料節點選擇樣板。</p><p translation-origin="off">The tree may include multiple node templates, where a template is chosen
for a particular data node via the <code>when</code> predicate of the template.</p>

<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">cdk-tree-node</span> *<span class="hljs-attr">cdkNodeDef</span>=<span class="hljs-string">"let node"</span> <span class="hljs-attr">cdkTreeNodePadding</span>&gt;</span>
  {{node.value}}
<span class="hljs-tag">&lt;/<span class="hljs-name">cdk-tree-node</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">cdk-tree-node</span> *<span class="hljs-attr">cdkNodeDef</span>=<span class="hljs-string">"let node; when: isSpecial"</span> <span class="hljs-attr">cdkTreeNodePadding</span>&gt;</span>
  [ A special node {{node.value}} ]
<span class="hljs-tag">&lt;/<span class="hljs-name">cdk-tree-node</span>&gt;</span>
</code></pre>

        <h3 id="data-source" class="docs-header-link" translation-result="on">
          <span header-link="資料來源"></span>
          資料來源
        </h3><h3 class="docs-header-link" translation-origin="off">
          <span header-link="data-source"></span>
          Data Source
        </h3>
      
        
      
        <h4 id="connecting-the-tree-to-a-data-source" class="docs-header-link" translation-result="on">
          <span header-link="把樹連線到資料來源"></span>
          把樹連線到資料來源
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="connecting-the-tree-to-a-data-source"></span>
          Connecting the tree to a data source
        </h4>
      
        
      <p translation-result="on">類似於 <code>cdk-table</code>，資料也透過 <code>DataSource</code> 提供給樹。當樹接收到一個 <code>DataSource</code> 時，就會呼叫資料來源的 <code>connect()</code> 方法，該方法回傳一個發出陣列型資料的可觀察物件。只要資料來源向此流中發出資料，該樹就會渲染出這些更新。</p><p translation-origin="off">Similar to <code>cdk-table</code>, data is provided to the tree through a <code>DataSource</code>. When the tree receives
a <code>DataSource</code> it will call its <code>connect()</code> method which returns an observable that emits an array
of data. Whenever the data source emits data to this stream, the tree will render an update.</p>

<p translation-result="on">由於資料來源提供了這個流，因此它要負責切換樹的更新。這可以來源於任何事：樹節點的展開狀態變化了、websocket 連線、使用者互動、模型更新、基於時間間隔等。</p><p translation-origin="off">Because the data source provides this stream, it bears the responsibility of toggling tree
updates. This can be based on anything: tree node expansion change, websocket connections, user
interaction, model updates, time-based intervals, etc.</p>


        <h4 id="flat-tree-1" class="docs-header-link" translation-result="on">
          <span header-link="扁平樹-1"></span>
          扁平樹
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="flat-tree-1"></span>
          Flat tree
        </h4>
      
        
      <p translation-result="on">扁平樹的資料來源要負責節點的展開/摺疊事件，因為當其展開狀態發生變化時，該樹的資料節點也會隨之變化。這些可視節點的新清單應該把當前的展開狀態傳送給樹的元件。</p><p translation-origin="off">The flat tree data source is responsible for the node expansion/collapsing events, since when
the expansion status changes, the data nodes feed to the tree are changed. A new list of visible
nodes should be sent to tree component based on current expansion status.</p>


        <h4 id="nested-tree-1" class="docs-header-link" translation-result="on">
          <span header-link="巢狀樹"></span>
          巢狀樹
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="nested-tree-1"></span>
          Nested tree
        </h4>
      
        
      <p translation-result="on">巢狀樹的資料來源有一個選項，可讓每個樹節點元件處理該節點的展開/摺疊事件。</p><p translation-origin="off">The data source for nested tree has an option to leave the node expansion/collapsing event for each
tree node component to handle.</p>


        <h5 id="trackby" class="docs-header-link">
          <span header-link="trackby"></span>
          <code>trackBy</code>
        </h5>
      <p translation-result="on">為了提高效能，可以為樹提供一個類似於 Angular 的 <a href="https://angular.cn/api/common/NgForOf#change-propagation"><code>ngFor</code> <code>trackBy</code></a>的<a href="https://angular.cn/api/common/NgForOf#change-propagation"><code>ngFor</code> <code>trackBy</code></a> 指令。這會告訴樹要如何唯一地標識節點，以跟蹤每次更新時數據的變化情況。</p><p translation-origin="off">To improve performance, a <code>trackBy</code> function can be provided to the tree similar to Angular」s
<a href="https://angular.io/api/common/NgForOf#change-propagation"><code>ngFor</code> <code>trackBy</code></a>. This informs the
tree how to uniquely identify nodes to track how the data changes with each update.</p>

<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">cdk-tree</span> [<span class="hljs-attr">dataSource</span>]=<span class="hljs-string">"dataSource"</span> [<span class="hljs-attr">treeControl</span>]=<span class="hljs-string">"treeControl"</span> [<span class="hljs-attr">trackBy</span>]=<span class="hljs-string">"trackByFn"</span>&gt;</span>
</code></pre>
</div>