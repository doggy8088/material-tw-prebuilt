<div class="docs-markdown"><p translation-result="on">Angular Material 提供了兩組元件，用以給主要內容新增一些可摺疊的附屬內容（通常是導向，但也可以是任何內容）。它們就是側邊欄（sidenav）和抽屜（drawer）元件。</p><p translation-origin="off">Angular Material provides two sets of components designed to add collapsible side content (often
navigation, though it can be any content) alongside some primary content. These are the sidenav and
drawer components.</p>

<p translation-result="on">側邊欄元件旨在為全屏應用新增附屬內容。要建立側邊欄，我們需要用到三個元件：<code>&lt;mat-sidenav-container&gt;</code> 用來為主要內容和側邊欄提供一個結構容器；<code>&lt;mat-sidenav-content&gt;</code> 用來表示主要內容，而 <code>&lt;mat-sidenav&gt;</code> 用於表示附屬內容。</p><p translation-origin="off">The sidenav components are designed to add side content to a fullscreen app. To set up a sidenav we
use three components: <code>&lt;mat-sidenav-container&gt;</code> which acts as a structural container for our content
and sidenav, <code>&lt;mat-sidenav-content&gt;</code> which represents the main content, and <code>&lt;mat-sidenav&gt;</code> which
represents the added side content.</p>

<div material-docs-example="sidenav-overview"></div>

<p translation-result="on">抽屜元件旨在給應用中的一小部分新增附屬內容。這可以使用 <code>&lt;mat-drawer-container&gt;</code>、<code>&lt;mat-drawer-content&gt;</code> 和 <code>&lt;mat-drawer&gt;</code> 來實現，它們分別是各個側邊欄元件的等價物。側邊欄會把應用的附屬內容作為整體新增進來，而抽屜只在為應用中的一小部分新增附屬內容。
它們所支援的大部分屬性都一樣，但抽屜不支援固定定位方式。</p><p translation-origin="off">The drawer component is designed to add side content to a small section of your app. This is
accomplished using the <code>&lt;mat-drawer-container&gt;</code>, <code>&lt;mat-drawer-content&gt;</code>, and <code>&lt;mat-drawer&gt;</code>
components, which are analogous to their sidenav equivalents. Rather than adding side content to the
app as a whole, these are designed to add side content to a small section of your app. They support
almost all of the same features, but do not support fixed positioning.</p>

<div material-docs-example="sidenav-drawer-overview"></div>


        <h3 id="specifying-the-main-and-side-content" class="docs-header-link" translation-result="on">
          <span header-link="指定主內容和附屬內容"></span>
          指定主內容和附屬內容
        </h3><h3 class="docs-header-link" translation-origin="off">
          <span header-link="specifying-the-main-and-side-content"></span>
          Specifying the main and side content
        </h3>
      
        
      <p translation-result="on">無論主內容還是附屬內容，都應該放在 <code>&lt;mat-sidenav-container&gt;</code> 的內部，而那些你不希望被側邊欄影響到的內容（比如頭或腳），可以放在該容器的外部。</p><p translation-origin="off">Both the main and side content should be placed inside of the <code>&lt;mat-sidenav-container&gt;</code>, content
that you don't want to be affected by the sidenav, such as a header or footer, can be placed outside
of the container.</p>

<p translation-result="on">附屬內容應該包裝在 <code>&lt;mat-sidenav&gt;</code> 元素中。它的 <code>position</code> 屬性可以指定主內容該放在附屬內容的哪一端，它可以是 <code>start</code> 或 <code>end</code>，在從左到右書寫的語言中下，分別表示把主內容放在附屬內容的左側或右側。
如果沒有指定 <code>position</code>，則其預設值是 <code>start</code>。
<code>&lt;mat-sidenav-container&gt;</code> 最多可以擁有兩個 <code>&lt;mat-sidenav&gt;</code> 元素，但每一側只能有一個。
<code>&lt;mat-sidenav&gt;</code> 必須作為 <code>&lt;mat-sidenav-container&gt;</code> 的直屬子節點出現。</p><p translation-origin="off">The side content should be wrapped in a <code>&lt;mat-sidenav&gt;</code> element. The <code>position</code> property can be used
to specify which end of the main content to place the side content on. <code>position</code> can be either
<code>start</code> or <code>end</code> which places the side content on the left or right respectively in left-to-right
languages. If the <code>position</code> is not set, the default value of <code>start</code> will be assumed. A
<code>&lt;mat-sidenav-container&gt;</code> can have up to two <code>&lt;mat-sidenav&gt;</code> elements total, but only one for any
given side. The <code>&lt;mat-sidenav&gt;</code> must be placed as an immediate child of the <code>&lt;mat-sidenav-container&gt;</code>.</p>

<p translation-result="on">主要內容應該包裹在 <code>&lt;mat-sidenav-content&gt;</code> 中，如果沒有為 <code>&lt;mat-sidenav-container&gt;</code> 指定 <code>&lt;mat-sidenav-content&gt;</code>，則會隱式建立一個，並把 <code>&lt;mat-sidenav-container&gt;</code> 中除了 <code>&lt;mat-sidenav&gt;</code> 元素之外的內容都放進去。</p><p translation-origin="off">The main content should be wrapped in a <code>&lt;mat-sidenav-content&gt;</code>. If no <code>&lt;mat-sidenav-content&gt;</code> is
specified for a <code>&lt;mat-sidenav-container&gt;</code>, one will be created implicitly and all of the content
inside the <code>&lt;mat-sidenav-container&gt;</code> other than the <code>&lt;mat-sidenav&gt;</code> elements will be placed inside
of it.</p>

<div material-docs-example="sidenav-position"></div>

<p translation-result="on">下面是正確使用側邊欄佈局的例子：</p><p translation-origin="off">The following are examples of valid sidenav layouts:</p>

<pre><code class="language-html"><span class="hljs-comment">&lt;!-- Creates a layout with a left-positioned sidenav and explicit content. --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mat-sidenav-container</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">mat-sidenav</span>&gt;</span>Start<span class="hljs-tag">&lt;/<span class="hljs-name">mat-sidenav</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">mat-sidenav-content</span>&gt;</span>Main<span class="hljs-tag">&lt;/<span class="hljs-name">mat-sidenav-content</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mat-sidenav-container</span>&gt;</span>
</code></pre>
<pre><code class="language-html"><span class="hljs-comment">&lt;!-- Creates a layout with a left and right sidenav and implicit content. --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mat-sidenav-container</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">mat-sidenav</span>&gt;</span>Start<span class="hljs-tag">&lt;/<span class="hljs-name">mat-sidenav</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">mat-sidenav</span> <span class="hljs-attr">position</span>=<span class="hljs-string">"end"</span>&gt;</span>End<span class="hljs-tag">&lt;/<span class="hljs-name">mat-sidenav</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span>Main<span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mat-sidenav-container</span>&gt;</span>
</code></pre>
<pre><code class="language-html"><span class="hljs-comment">&lt;!-- Creates an empty sidenav container with no sidenavs and implicit empty content. --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mat-sidenav-container</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mat-sidenav-container</span>&gt;</span>
</code></pre>
<p translation-result="on">下面是錯誤使用側邊欄佈局的例子：</p><p translation-origin="off">And these are examples of invalid sidenav layouts:</p>

<pre><code class="language-html"><span class="hljs-comment">&lt;!-- Invalid because there are two `start` position sidenavs. --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mat-sidenav-container</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">mat-sidenav</span>&gt;</span>Start<span class="hljs-tag">&lt;/<span class="hljs-name">mat-sidenav</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">mat-sidenav</span> <span class="hljs-attr">position</span>=<span class="hljs-string">"start"</span>&gt;</span>Start 2<span class="hljs-tag">&lt;/<span class="hljs-name">mat-sidenav</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mat-sidenav-container</span>&gt;</span>
</code></pre>
<pre><code class="language-html"><span class="hljs-comment">&lt;!-- Invalid because there are multiple `&lt;mat-sidenav-content&gt;` elements. --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mat-sidenav-container</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">mat-sidenav-content</span>&gt;</span>Main<span class="hljs-tag">&lt;/<span class="hljs-name">mat-sidenav-content</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">mat-sidenav-content</span>&gt;</span>Main 2<span class="hljs-tag">&lt;/<span class="hljs-name">mat-sidenav-content</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mat-sidenav-container</span>&gt;</span>
</code></pre>
<pre><code class="language-html"><span class="hljs-comment">&lt;!-- Invalid because the `&lt;mat-sidenav&gt;` is outside of the `&lt;mat-sidenav-container&gt;`. --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mat-sidenav-container</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mat-sidenav-container</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mat-sidenav</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mat-sidenav</span>&gt;</span>
</code></pre>
<p translation-result="on">這些規則也同樣適用於抽屜元件。</p><p translation-origin="off">These same rules all apply to the drawer components as well.</p>


        <h3 id="opening-and-closing-a-sidenav" class="docs-header-link" translation-result="on">
          <span header-link="開啟和關閉側邊欄"></span>
          開啟和關閉側邊欄
        </h3><h3 class="docs-header-link" translation-origin="off">
          <span header-link="opening-and-closing-a-sidenav"></span>
          Opening and closing a sidenav
        </h3>
      
        
      <p translation-result="on"><code>&lt;mat-sidenav&gt;</code> 可以使用 <code>open()</code>、<code>close()</code> 和 <code>toggle()</code> 方法來開啟或關閉。
它們都會回傳一個 <code>Promise&lt;boolean&gt;</code>，當側邊欄開啟之後它會解析為 <code>true</code>，關閉之後解析為 <code>false</code>。</p><p translation-origin="off">A <code>&lt;mat-sidenav&gt;</code> can be opened or closed using the <code>open()</code>, <code>close()</code> and <code>toggle()</code> methods. Each
of these methods returns a <code>Promise&lt;boolean&gt;</code> that will be resolved with <code>true</code> when the sidenav
finishes opening or <code>false</code> when it finishes closing.</p>

<p translation-result="on">這些開啟狀態也可以在樣板中使用 <code>opened</code> 屬性進行設定。該屬性支援雙向繫結。</p><p translation-origin="off">The opened state can also be set via a property binding in the template using the <code>opened</code> property.
The property supports 2-way binding.</p>

<p translation-result="on"><code>&lt;mat-sidenav&gt;</code> 也支援一些輸出屬性：<code>(opened)</code> 表示剛剛開啟，<code>(closed)</code> 表示剛剛關閉。</p><p translation-origin="off"><code>&lt;mat-sidenav&gt;</code> also supports output properties for just open and just close events, The <code>(opened)</code>
and <code>(closed)</code> properties respectively.</p>

<div material-docs-example="sidenav-open-close"></div>

<p translation-result="on">所有這些屬性和方法也同樣可用在 <code>&lt;mat-drawer&gt;</code> 上。</p><p translation-origin="off">All of these properties and methods work on <code>&lt;mat-drawer&gt;</code> as well.</p>


        <h3 id="changing-the-sidenavs-behavior" class="docs-header-link" translation-result="on">
          <span header-link="修改側邊欄的行為"></span>
          修改側邊欄的行為
        </h3><h3 class="docs-header-link" translation-origin="off">
          <span header-link="changing-the-sidenavs-behavior"></span>
          Changing the sidenav's behavior
        </h3>
      
        
      <p translation-result="on"><code>&lt;mat-sidenav&gt;</code> 可以根據其 <code>mode</code> 屬性的值以三種方式之一進行渲染。</p><p translation-origin="off">The <code>&lt;mat-sidenav&gt;</code> can render in one of three different ways based on the <code>mode</code> property.</p>

<table>
<thead>
<tr>
<th><nt-wrapper translation-result="on">模式</nt-wrapper><nt-wrapper translation-origin="off">Mode</nt-wrapper></th>
<th><nt-wrapper translation-result="on">說明</nt-wrapper><nt-wrapper translation-origin="off">Description</nt-wrapper></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>over</code></td>
<td><nt-wrapper translation-result="on">側邊欄浮在主內容上方，並用一個背景遮住主內容</nt-wrapper><nt-wrapper translation-origin="off">Sidenav floats over the primary content, which is covered by a backdrop</nt-wrapper></td>
</tr>

<tr>
<td><code>push</code></td>
<td><nt-wrapper translation-result="on">側邊欄把主內容擠出去，並用一個背景遮住主內容</nt-wrapper><nt-wrapper translation-origin="off">Sidenav pushes the primary content out of its way, also covering it with a backdrop</nt-wrapper></td>
</tr>

<tr>
<td><code>side</code></td>
<td><nt-wrapper translation-result="on">側邊欄和主內容並排顯示，並收縮主內容的寬度，給側邊欄騰出空間</nt-wrapper><nt-wrapper translation-origin="off">Sidenav appears side-by-side with the main content, shrinking the main content's width to make space for the sidenav.</nt-wrapper></td>
</tr>

</tbody></table>
<p translation-result="on">如果沒有指定 <code>mode</code>，則預設為 <code>over</code>。</p><p translation-origin="off">If no <code>mode</code> is specified, <code>over</code> is used by default.</p>

<div material-docs-example="sidenav-mode"></div>

<p translation-result="on">側邊欄的 <code>over</code> 和 <code>push</code> 模式預設會顯示一個背景，但 <code>side</code> 模式不會。這可以透過 <code>mat-sidenav-container</code> 上的
<code>hasBackdrop</code> 屬性進行設定。顯式把 <code>hasBackdrop</code> 設定為 <code>true</code> 或 <code>false</code> 將會為側邊欄改寫預設的背景可見性，而不管處在什麼模式下。不設定該屬性或把它設定為 <code>null</code> 將會使用每種模式下預設的背景可見性。</p><p translation-origin="off">The <code>over</code> and <code>push</code> sidenav modes show a backdrop by default, while the <code>side</code> mode does not. This
can be customized by setting the <code>hasBackdrop</code> property on <code>mat-sidenav-container</code>. Explicitly
setting <code>hasBackdrop</code> to <code>true</code> or <code>false</code> will override the default backdrop visibility setting for
all sidenavs regardless of mode. Leaving the property unset or setting it to <code>null</code> will use the
default backdrop visibility for each mode.</p>

<div material-docs-example="sidenav-backdrop"></div>

<p translation-result="on"><code>&lt;mat-drawer&gt;</code> 也同樣支援這些模式和選項。</p><p translation-origin="off"><code>&lt;mat-drawer&gt;</code> also supports all of these same modes and options.</p>


        <h3 id="disabling-automatic-close" class="docs-header-link" translation-result="on">
          <span header-link="停用自動關閉功能"></span>
          停用自動關閉功能
        </h3><h3 class="docs-header-link" translation-origin="off">
          <span header-link="disabling-automatic-close"></span>
          Disabling automatic close
        </h3>
      
        
      <p translation-result="on">點選背景或按下 <kbd>Esc</kbd> 鍵通常會關閉側邊欄。
不過，可以透過設定 <code>&lt;mat-sidenav&gt;</code> 或 <code>&lt;mat-drawer&gt;</code> 上的 <code>disableClose</code> 屬性來停用這種自動關閉的行為。</p><p translation-origin="off">Clicking on the backdrop or pressing the <kbd>Esc</kbd> key will normally close an open sidenav.
However, this automatic closing behavior can be disabled by setting the <code>disableClose</code> property on
the <code>&lt;mat-sidenav&gt;</code> or <code>&lt;mat-drawer&gt;</code> that you want to disable the behavior for.</p>

<p translation-result="on">可以透過給 <code>&lt;mat-sidenav&gt;</code> 新增 <code>keydown</code> 監聽器來定製 <kbd>Esc</kbd> 處理器。
可以透過 <code>&lt;mat-sidenav-container&gt;</code> 的輸出屬性 <code>(backdropClick)</code> 來定製點選背景的處理器。</p><p translation-origin="off">Custom handling for <kbd>Esc</kbd> can be done by adding a keydown listener to the <code>&lt;mat-sidenav&gt;</code>.
Custom handling for backdrop clicks can be done via the <code>(backdropClick)</code> output property on
<code>&lt;mat-sidenav-container&gt;</code>.</p>

<div material-docs-example="sidenav-disable-close"></div>


        <h3 id="resizing-an-open-sidenav" class="docs-header-link" translation-result="on">
          <span header-link="調整開啟側邊欄的大小"></span>
          調整開啟側邊欄的大小
        </h3><h3 class="docs-header-link" translation-origin="off">
          <span header-link="resizing-an-open-sidenav"></span>
          Resizing an open sidenav
        </h3>
      
        
      <p translation-result="on">預設情況下，Material 只會在一些關鍵時刻（開啟、視窗調整大小、模式改變）測量和調整容器的大小，以避免佈局顛簸。
但是在某些情況下這可能會有問題。如果你希望在開啟抽屜時更改其寬度，可以使用 <code>autosize</code> 選項來告訴 Material 繼續測量它。
注意，使用該選項時應該<strong>風險自擔</strong>，因為它可能會導致效能問題。</p><p translation-origin="off">By default, Material will only measure and resize the drawer container in a few key moments
(on open, on window resize, on mode change) in order to avoid layout thrashing, however there
are cases where this can be problematic. If your app requires for a drawer to change its width
while it is open, you can use the <code>autosize</code> option to tell Material to continue measuring it.
Note that you should use this option <strong>at your own risk</strong>, because it could cause performance
issues.</p>

<div material-docs-example="sidenav-autosize"></div>


        <h3 id="setting-the-sidenavs-size" class="docs-header-link" translation-result="on">
          <span header-link="設定側邊欄大小"></span>
          設定側邊欄大小
        </h3><h3 class="docs-header-link" translation-origin="off">
          <span header-link="setting-the-sidenavs-size"></span>
          Setting the sidenav's size
        </h3>
      
        
      <p translation-result="on">預設情況下，<code>&lt;mat-sidenav&gt;</code> 和 <code>&lt;mat-drawer&gt;</code> 應該自適應其內容的尺寸。不過也可以透過 CSS 來顯式指定寬度：</p><p translation-origin="off">The <code>&lt;mat-sidenav&gt;</code> and <code>&lt;mat-drawer&gt;</code> will, by default, fit the size of its content. The width can
be explicitly set via CSS:</p>

<pre><code class="language-css">mat-sidenav {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;
}
</code></pre>
<p translation-result="on">避免使用基於百分比的寬度，因為 <code>resize</code> 事件尚未支援它。</p><p translation-origin="off">Try to avoid percent based width as <code>resize</code> events are not (yet) supported.</p>


        <h3 id="fixed-position-sidenavs" class="docs-header-link" translation-result="on">
          <span header-link="固定定位的側邊欄"></span>
          固定定位的側邊欄
        </h3><h3 class="docs-header-link" translation-origin="off">
          <span header-link="fixed-position-sidenavs"></span>
          Fixed position sidenavs
        </h3>
      
        
      <p translation-result="on"><code>&lt;mat-sidenav&gt;</code> 只支援固定定位方式（<code>&lt;mat-drawer&gt;</code> 不限）。它可以透過設定 <code>fixedInViewport</code> 屬性進行啟用。
另外，還可以透過 <code>fixedTopGap</code> 和 <code>fixedBottomGap</code> 來設定頂部和底部的空白。這些屬性可以接受一個畫素值來指定要加到頂部或底部的空白尺寸。</p><p translation-origin="off">For <code>&lt;mat-sidenav&gt;</code> only (not <code>&lt;mat-drawer&gt;</code>) fixed positioning is supported. It can be enabled by
setting the <code>fixedInViewport</code> property. Additionally, top and bottom space can be set via the
<code>fixedTopGap</code> and <code>fixedBottomGap</code>. These properties accept a pixel value amount of space to add at
the top or bottom.</p>

<div material-docs-example="sidenav-fixed"></div>


        <h3 id="creating-a-responsive-layout-for-mobile--desktop" class="docs-header-link" translation-result="on">
          <span header-link="為行動端和桌面建立回應式佈局"></span>
          為行動端和桌面建立回應式佈局
        </h3><h3 class="docs-header-link" translation-origin="off">
          <span header-link="creating-a-responsive-layout-for-mobile--desktop"></span>
          Creating a responsive layout for mobile &amp; desktop
        </h3>
      
        
      <p translation-result="on">側邊欄通常要在行動端和桌面端提供不同的行為。在桌面端，只允許內容區捲動是合理的；在行動端，你通常會希望捲動整個 <code>body</code>，這樣就能讓瀏覽器自動隱藏地址欄。側邊欄可以使用 CSS 來設定樣式，以針對不同型別的裝置進行調整。</p><p translation-origin="off">A sidenav often needs to behave differently on a mobile vs a desktop display. On a desktop, it may
make sense to have just the content section scroll. However, on mobile you often want the body to be
the element that scrolls; this allows the address bar to auto-hide. The sidenav can be styled with
CSS to adjust to either type of device.</p>

<div material-docs-example="sidenav-responsive"></div>


        <h3 id="reacting-to-scroll-events-inside-the-sidenav-container" class="docs-header-link" translation-result="on">
          <span header-link="回應側邊欄內部的捲動事件"></span>
          回應側邊欄內部的捲動事件
        </h3><h3 class="docs-header-link" translation-origin="off">
          <span header-link="reacting-to-scroll-events-inside-the-sidenav-container"></span>
          Reacting to scroll events inside the sidenav container
        </h3>
      
        
      <p translation-result="on">要回應 <code>&lt;mat-sidenav-container&gt;</code> 內部的捲動事件，你可以透過 <code>MatSidenavContainer</code> 來獲取一個底層的 <code>CdkScrollable</code> 實例。</p><p translation-origin="off">To react to scrolling inside the <code>&lt;mat-sidenav-container&gt;</code>, you can get a hold of the underlying
<code>CdkScrollable</code> instance through the <code>MatSidenavContainer</code>.</p>

<pre><code class="language-ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">YourComponent</span> <span class="hljs-title">implements</span> <span class="hljs-title">AfterViewInit</span> </span>{
  <span class="hljs-meta">@ViewChild</span>(MatSidenavContainer) sidenavContainer: MatSidenavContainer;

  <span class="hljs-function"><span class="hljs-title">ngAfterViewInit</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-built_in">this</span>.sidenavContainer.scrollable.elementScrolled().subscribe(<span class="hljs-function">() =&gt;</span> <span class="hljs-comment">/* react to scrolling */</span>);
  }
}
</code></pre>

        <h3 id="accessibility" class="docs-header-link" translation-result="on">
          <span header-link="無障礙性"></span>
          無障礙性
        </h3><h3 class="docs-header-link" translation-origin="off">
          <span header-link="accessibility"></span>
          Accessibility
        </h3>
      
        
      <p translation-result="on"><code>&lt;mat-sidenav&gt;</code> 和 <code>&lt;mat-sidenav-content&gt;</code> 都應該根據它們的上下文給出一個合適的 <code>role</code> 屬性。</p><p translation-origin="off">The <code>&lt;mat-sidenav&gt;</code> and <code>&lt;mat-sidenav-content&gt;</code> should each be given an appropriate <code>role</code> attribute
depending on the context in which they are used.</p>

<p translation-result="on">比如，包含到其它頁面的連結的 <code>&lt;mat-sidenav&gt;</code> 可以標記為 <code>role="navigation"</code>，而包含目錄的則應該標記為 <code>role="directory"</code>。
如果沒有什麼特別的角色來描述這個側邊欄，建議使用 <code>role="region"</code>。</p><p translation-origin="off">For example, a <code>&lt;mat-sidenav&gt;</code> that contains links
to other pages might be marked <code>role="navigation"</code>, whereas one that contains a table of
contents about might be marked as <code>role="directory"</code>. If there is no more specific role that
describes your sidenav, <code>role="region"</code> is recommended.</p>

<p translation-result="on">同樣，<code>&lt;mat-sidenav-content&gt;</code> 也應該基於其包含的內容來指定角色。如果它表示頁面的主要內容，就應該標記為 <code>role="main"</code>。
如果沒辦法指定合理的角色，同樣可以用 <code>role="region"</code> 作為回退值。</p><p translation-origin="off">Similarly, the <code>&lt;mat-sidenav-content&gt;</code> should be given a role based on what it contains. If it
represents the primary content of the page, it may make sense to mark it <code>role="main"</code>. If no more
specific role makes sense, <code>role="region"</code> is again a good fallback.</p>


        <h4 id="focus-management" class="docs-header-link" translation-result="on">
          <span header-link="焦點管理"></span>
          焦點管理
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="focus-management"></span>
          Focus management
        </h4>
      
        
      <p translation-result="on">sidenav 能夠捕獲焦點。此功能在 <code>push</code> 和 <code>over</code> 模式下開啟，在 <code>side</code> 模式下則被關閉。你可以透過輸入屬性 <code>autoFocus</code> 來改變其預設行為。</p><p translation-origin="off">The sidenav has the ability to capture focus. This behavior is turned on for the <code>push</code> and <code>over</code> modes and it is off for <code>side</code> mode. You can change its default behavior by the <code>autoFocus</code> input.</p>

<p translation-result="on">預設情況下，一旦開啟，其中的第一個可接收焦點的元素就會收到焦點。如果你想讓另一個元素獲得焦點，可以在它上面新增 <code>cdkFocusInitial</code> 屬性。</p><p translation-origin="off">By default the first tabbable element will receive focus upon open. If you want a different element to be focused, you can set the <code>cdkFocusInitial</code> attribute on it.</p>


        <h3 id="troubleshooting" class="docs-header-link" translation-result="on">
          <span header-link="排查問題"></span>
          排查問題
        </h3><h3 class="docs-header-link" translation-origin="off">
          <span header-link="troubleshooting"></span>
          Troubleshooting
        </h3>
      
        
      
        <h4 id="error-a-drawer-was-already-declared-for-position" class="docs-header-link" translation-result="on">
          <span header-link="error-a-drawer-was-already-declared-for-position-（指定的-position-處已經宣告了一個抽屜）"></span>
          Error: A drawer was already declared for 'position="..."' <br>（指定的 'position="..."' 處已經宣告了一個抽屜）
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="error-a-drawer-was-already-declared-for-position"></span>
          Error: A drawer was already declared for 'position="..."'
        </h4>
      
        
      <p translation-result="on">如果在指定容器的同一個 <code>position</code> 有多個側邊欄或抽屜，就會丟擲本錯誤。
由於 <code>position</code> 屬性預設為 <code>start</code>，所以出現該問題可能只是因為你忘了給 <code>end</code> 側邊欄標記上 <code>position="end"</code>。</p><p translation-origin="off">This error is thrown if you have more than one sidenav or drawer in a given container with the same
<code>position</code>. The <code>position</code> property defaults to <code>start</code>, so the issue may just be that you forgot to
mark the <code>end</code> sidenav with <code>position="end"</code>.</p>

</div>