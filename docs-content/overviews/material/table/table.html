<div class="docs-markdown"><p translation-result="on"><code>mat-table</code> 提供了一個支援 Material Design 樣式的表格，可用來顯示多行資料。</p><p translation-origin="off">The <code>mat-table</code> provides a Material Design styled data-table that can be used to display rows of
data.</p>

<p translation-result="on">此表格基於 CDK 中的 data-table 建立，並在資料輸入和樣板上採用了相同的介面，只是它的元素選擇器和屬性選擇器都使用 <code>mat-</code> 字首，而不是 <code>cdk-</code> 字首。
對於該介面的更多訊息以及表格的具體實現方式，參見 <a href="/guide/cdk-table">CDK data-table 指南</a>。</p><p translation-origin="off">This table builds on the foundation of the CDK data-table and uses a similar interface for its
data input and template, except that its element and attribute selectors will be prefixed
with <code>mat-</code> instead of <code>cdk-</code>. For more information on the interface and a detailed look at how
the table is implemented, see the
<a href="https://material.angular.io/guide/cdk-table">guide covering the CDK data-table</a>.</p>


        <h3 id="getting-started" class="docs-header-link" translation-result="on">
          <span header-link="快速上手"></span>
          快速上手
        </h3><h3 class="docs-header-link" translation-origin="off">
          <span header-link="getting-started"></span>
          Getting Started
        </h3>
      
        
      <div material-docs-example="table-basic"></div>


        <h4 id="1-write-your-mat-table-and-provide-data" class="docs-header-link" translation-result="on">
          <span header-link="1-編寫你的-mat-table-並提供資料"></span>
          1. 編寫你的 mat-table 並提供資料
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="1-write-your-mat-table-and-provide-data"></span>
          1. Write your mat-table and provide data
        </h4>
      
        
      <p translation-result="on">先把 <code>&lt;table mat-table&gt;</code> 元件新增到樣板中，並傳入資料。</p><p translation-origin="off">Begin by adding the <code>&lt;table mat-table&gt;</code> component to your template and passing in data.</p>

<p translation-result="on">為表格提供資料的最簡單方式就是給它的輸入屬性 <code>dataSource</code> 提供一個陣列型資料。
該表格將會接收這個陣列，並把陣列型資料中的每一個物件渲染成一行。</p><p translation-origin="off">The simplest way to provide data to the table is by passing a data array to the table's <code>dataSource</code>
input. The table will take the array and render a row for each object in the data array.</p>

<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">mat-table</span> [<span class="hljs-attr">dataSource</span>]=<span class="hljs-string">"myDataArray"</span>&gt;</span>
  ...
<span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span>
</code></pre>
<p translation-result="on">為了最佳化表格的效能，它不會自動檢查陣列型資料的變更。而是要在每次在資料表中新增、刪除或移動物件時，透過呼叫它的 <code>renderRows</code> 方法來更新表格的各行。</p><p translation-origin="off">Since the table optimizes for performance, it will not automatically check for changes to the data
array. Instead, when objects are added, removed, or moved on the data array, you can trigger an
update to the table's rendered rows by calling its <code>renderRows()</code> method.</p>

<p translation-result="on">雖然陣列是把資料繫結到資料來源的<em>最簡單的</em>方式，但它也受限最嚴重。對於更復雜的應用，建議使用 <code>DataSource</code> 實例。參見稍後的 "高階資料來源" 部分瞭解更多。</p><p translation-origin="off">While an array is the <em>simplest</em> way to bind data into the data source, it is also
the most limited. For more complex applications, using a <code>DataSource</code> instance
is recommended. See the section "Advanced data sources" below for more information.</p>


        <h4 id="2-define-the-column-templates" class="docs-header-link" translation-result="on">
          <span header-link="2-定義列樣板"></span>
          2. 定義列樣板
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="2-define-the-column-templates"></span>
          2. Define the column templates
        </h4>
      
        
      <p translation-result="on">接著，編寫表格的列樣板。</p><p translation-origin="off">Next, write your table's column templates.</p>

<p translation-result="on">每個列定義都應該有一個唯一的名字，並且包含其表頭單元格和行內單元格的內容。</p><p translation-origin="off">Each column definition should be given a unique name and contain the content for its header and row
cells.</p>

<p translation-result="on">下面是一個名為 <code>'username'</code> 的簡單列定義。
表頭單元格包含一個文字 "Name"，每個行內單元格將會渲染出每行數據中 <code>name</code> 屬性的值。</p><p translation-origin="off">Here's a simple column definition with the name <code>'score'</code>. The header cell contains the text
"Score" and each row cell will render the <code>score</code> property of each row's data.</p>

<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">ng-container</span> <span class="hljs-attr">matColumnDef</span>=<span class="hljs-string">"score"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">mat-header-cell</span> *<span class="hljs-attr">matHeaderCellDef</span>&gt;</span> Score <span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">mat-cell</span> *<span class="hljs-attr">matCellDef</span>=<span class="hljs-string">"let user"</span>&gt;</span> {{user.score}} <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ng-container</span>&gt;</span>
</code></pre>
<p translation-result="on">請注意，單元格樣板不僅限於顯示簡單的字串值，它非常靈活，可以讓你提供任何樣板。</p><p translation-origin="off">Note that the cell templates are not restricted to only showing simple string values, but are
flexible and allow you to provide any template.</p>

<p translation-result="on">如果你的列只負責為表頭和單元格渲染一個字串值，可以改用 <code>mat-text-column</code> 來定義它。下面的列定義與上面的列定義是等價的。</p><p translation-origin="off">If your column is only responsible for rendering a single string value for the header and cells,
you can instead define your column using the <code>mat-text-column</code>. The following column definition is
equivalent to the one above.</p>

<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">mat-text-column</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"score"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mat-text-column</span>&gt;</span>
</code></pre>
<p translation-result="on">檢視 API 文件和 <code>mat-text-column</code> 的例子，以瞭解如何自定義表頭文字、文字對齊方式和單元格資料訪問器。請注意，這與 flex-layout 表不相容。此外，如果資料的屬性最小化過，則應提供資料訪問器，因為屬性名和字串名稱在最小化後將不再對應。</p><p translation-origin="off">Check out the API docs and examples of the <code>mat-text-column</code> to see how you can customize the header
text, text alignment, and cell data accessor.  Note that this is not compatible with the flex-layout
table. Also, a data accessor should be provided if your data may have its properties minified
since the string name will no longer match after minification.</p>


        <h4 id="3-define-the-row-templates" class="docs-header-link" translation-result="on">
          <span header-link="3-定義行樣板"></span>
          3. 定義行樣板
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="3-define-the-row-templates"></span>
          3. Define the row templates
        </h4>
      
        
      <p translation-result="on">最後，一旦你定義了各個列，就要告訴表格該在表頭和數據行中顯示哪些列。</p><p translation-origin="off">Finally, once you have defined your columns, you need to tell the table which columns will be
rendered in the header and data rows.</p>

<p translation-result="on">先在元件中建立一個變數，其中包含你要渲染的列數組。</p><p translation-origin="off">To start, create a variable in your component that contains the list of the columns you want to
render.</p>

<pre><code class="language-ts">columnsToDisplay = [<span class="hljs-string">'userName'</span>, <span class="hljs-string">'age'</span>];
</code></pre>
<p translation-result="on">然後，把 <code>mat-header-row</code> 和 <code>mat-row</code> 作為內容新增到 <code>mat-table</code> 中，並提供你的列數組作為輸入。</p><p translation-origin="off">Then add <code>mat-header-row</code> and <code>mat-row</code> to the content of your <code>mat-table</code> and provide your
column list as inputs.</p>

<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">mat-header-row</span> *<span class="hljs-attr">matHeaderRowDef</span>=<span class="hljs-string">"columnsToDisplay"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">mat-row</span> *<span class="hljs-attr">matRowDef</span>=<span class="hljs-string">"let myRowData; columns: columnsToDisplay"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
</code></pre>
<p translation-result="on">注意，提供給各行的列數組可以使用任意順序，不要求和定義列的順序一致。同樣的，你也不必包含樣板中定義的每一列。</p><p translation-origin="off">Note that this list of columns provided to the rows can be in any order, not necessarily the order in
which you wrote the column definitions. Also, you do not necessarily have to include every column
that was defined in your template.</p>

<p translation-result="on">這意味著透過調整提供給各行的列順序，你可以輕易調整列序和動態包含/排除某些列。</p><p translation-origin="off">This means that by changing your column list provided to the rows, you can easily re-order and
include/exclude columns dynamically.</p>


        <h3 id="advanced-data-sources" class="docs-header-link" translation-result="on">
          <span header-link="高階資料結構"></span>
          高階資料結構
        </h3><h3 class="docs-header-link" translation-origin="off">
          <span header-link="advanced-data-sources"></span>
          Advanced data sources
        </h3>
      
        
      <p translation-result="on">為表格提供資料的最簡單方式是傳入一個陣列型資料。對於更復雜的用例，則可以從一些更靈活的方式中受益，比如使用 Observable 流，或把你的資料來源邏輯封裝進 <code>DataSource</code> 類別中。</p><p translation-origin="off">The simplest way to provide data to your table is by passing a data array. More complex use-cases
may benefit from a more flexible approach involving an Observable stream or by encapsulating your
data source logic into a <code>DataSource</code> class.</p>


        <h4 id="observable-stream-of-data-arrays" class="docs-header-link" translation-result="on">
          <span header-link="陣列型資料的-observable-流"></span>
          陣列型資料的 Observable 流
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="observable-stream-of-data-arrays"></span>
          Observable stream of data arrays
        </h4>
      
        
      <p translation-result="on">為表格提供資料的另一種方法是傳入一個 Observable 流，每當它變化時都會發出一個要渲染的陣列型資料。
表格會監聽這個流，每當它發出新的陣列型資料時，就會自動觸發一次更新。</p><p translation-origin="off">An alternative approach to providing data to the table is by passing an Observable stream that emits
the data array to be rendered each time it is changed. The table will listen to this stream and
automatically trigger an update to the rows each time a new data array is emitted.</p>


        <h4 id="datasource" class="docs-header-link" translation-result="on">
          <span header-link="datasource（資料來源）"></span>
          DataSource（資料來源）
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="datasource"></span>
          DataSource
        </h4>
      
        
      <p translation-result="on">對於大多數真實世界中的應用，為表格提供一個 <code>DataSource</code> 實例都會是管理資料的最佳方式。
<code>DataSource</code> 旨在封裝此應用特有的排序、過濾、分頁和數據接收邏輯。</p><p translation-origin="off">For most real-world applications, providing the table a <code>DataSource</code> instance will be the best way to
manage data. The <code>DataSource</code> is meant to serve as a place to encapsulate any sorting, filtering,
pagination, and data retrieval logic specific to the application.</p>

<p translation-result="on">DataSource 是一個至少擁有兩個函式的類：<code>connect</code> 和 <code>disconnect</code>。
表格會呼叫 <code>connect</code> 函式，以接收一個流，流中會發出要渲染的陣列型資料。當表格銷燬時，就會呼叫 <code>disconnect</code>，它是清理 <code>connect</code> 期間所做的各種訂閱的最佳時機。</p><p translation-origin="off">A <code>DataSource</code> is simply a class that has at a minimum the following methods: <code>connect</code> and
<code>disconnect</code>. The <code>connect</code> method will be called by the table to provide an <code>Observable</code> that emits
the data array that should be rendered. The table will call <code>disconnect</code> when the table is destroyed,
which may be the right time to clean up any subscriptions that may have been registered in the
<code>connect</code> method.</p>

<p translation-result="on">雖然 Angular Material 提供了現成的表格 <code>DataSource</code> 類 <code>MatTableDataSource</code>，但是你可能希望針對更復雜的用例建立自己的 <code>DataSource</code> 類。你可以用一個自定義的 <code>DataSource</code> 類來擴充套件抽象類別 <code>DataSource</code>，然後實現其 <code>connect</code> 和 <code>disconnect</code> 方法。對於這些複雜用例，自定義 <code>DataSource</code> 必須透過擴充套件其他基底類別（ <code>MyCustomDataSource extends SomeOtherBaseClass implements DataSource</code> ）來繼承其功能，以遵守 Typescript 的限制，即只能實現一個基底類別。</p><p translation-origin="off">Although Angular Material provides a ready-made table <code>DataSource</code> class, <code>MatTableDataSource</code>, you may
want to create your own custom <code>DataSource</code> class for more complex use cases. This can be done by
extending the abstract <code>DataSource</code> class with a custom <code>DataSource</code> class that then implements the
<code>connect</code> and <code>disconnect</code> methods. For use cases where the custom <code>DataSource</code> must also inherit
functionality by extending a different base class, the <code>DataSource</code> base class can be
implemented instead (<code>MyCustomDataSource extends SomeOtherBaseClass implements DataSource</code>) to
respect Typescript's restriction to only implement one base class.</p>


        <h3 id="styling-columns" class="docs-header-link" translation-result="on">
          <span header-link="樣式列"></span>
          樣式列
        </h3><h3 class="docs-header-link" translation-origin="off">
          <span header-link="styling-columns"></span>
          Styling Columns
        </h3>
      
        
      <p translation-result="on">每個表格單元格都有一個基於它出現在哪一列自動生成的類。這個生成的類別的格式是 <code>mat-column-NAME</code> 。例如，可以使用選擇器 <code>.mat-column-symbol</code> 將名為『symbol』的列中的單元格作為目標。</p><p translation-origin="off">Each table cell has an automatically generated class based on which column it appears in. The format for this
generated class is <code>mat-column-NAME</code>. For example, cells in a column named "symbol" can be targeted with the
selector <code>.mat-column-symbol</code>.</p>

<div material-docs-example="table-column-styling"></div>


        <h3 id="row-templates" class="docs-header-link" translation-result="on">
          <span header-link="行樣板"></span>
          行樣板
        </h3><h3 class="docs-header-link" translation-origin="off">
          <span header-link="row-templates"></span>
          Row Templates
        </h3>
      
        
      <p translation-result="on">行樣板上的事件處理程式和屬性繫結將應用於表中渲染的每一行。例如，向行樣板新增 <code>(click)</code> 處理程式將導致每個單獨的行在單擊時調用處理程式。</p><p translation-origin="off">Event handlers and property binding on the row templates will be applied to each row rendered by the table. For example,
adding a <code>(click)</code> handler to the row template will cause each individual row to call the handler when clicked.</p>

<div material-docs-example="table-row-binding"></div>


        <h3 id="features" class="docs-header-link" translation-result="on">
          <span header-link="屬性"></span>
          屬性
        </h3><h3 class="docs-header-link" translation-origin="off">
          <span header-link="features"></span>
          Features
        </h3>
      
        
      <p translation-result="on"><code>MatTable</code> 專注於一個職責：以高效且具有無障礙性的方式執行資料渲染。</p><p translation-origin="off">The <code>MatTable</code> is focused on a single responsibility: efficiently render rows of data in a
performant and accessible way.</p>

<p translation-result="on">你可能注意到了，表格本身並沒有自帶很多屬性，而是把該表格作為一個元件聯合體的一部分，來補全其它屬性。</p><p translation-origin="off">You'll notice that the table itself doesn't come out of the box with a lot of features, but expects
that the table will be included in a composition of components that fills out its features.</p>

<p translation-result="on">比如，你可以把 <code>MatSort</code> 和 <code>MatPaginator</code> 新增到表格中，以提供排序和分頁屬性，並根據它們的輸出來修改要傳給表格的資料。</p><p translation-origin="off">For example, you can add sorting and pagination to the table by using MatSort and MatPaginator and
mutating the data provided to the table according to their outputs.</p>

<p translation-result="on">對於那些可以對陣列型資料進行排序、分頁和過濾功能的表格，為了簡化其用法，Angular Material 函式庫自帶了一個 <code>MatTableDataSource</code>，它已經實現了根據當前表格的狀態來決定要顯示哪些列的邏輯。
要給表格新增這些屬性，請檢視其相關部分的文件。</p><p translation-origin="off">To simplify the use case of having a table that can sort, paginate, and filter an array of data,
the Angular Material library comes with a <code>MatTableDataSource</code> that has already implemented
the logic of determining what rows should be rendered according to the current table state. To add
these feature to the table, check out their respective sections below.</p>


        <h4 id="pagination" class="docs-header-link" translation-result="on">
          <span header-link="分頁"></span>
          分頁
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="pagination"></span>
          Pagination
        </h4>
      
        
      <p translation-result="on">要想對錶格資料進行分頁，請在表格後新增一個 <code>&lt;mat-paginator&gt;</code>。</p><p translation-origin="off">To paginate the table's data, add a <code>&lt;mat-paginator&gt;</code> after the table.</p>

<p translation-result="on">如果你正在用 <code>MatTableDataSource</code> 作為表格的資料來源，那麼只要把 <code>MatPaginator</code> 提供給這個資料來源就可以了。
它將會自動監聽使用者所做的頁碼變更，並把正確分頁之後的資料發給該表格。</p><p translation-origin="off">If you are using the <code>MatTableDataSource</code> for your table's data source, simply provide the
<code>MatPaginator</code> to your data source. It will automatically listen for page changes made by the user
and send the right paged data to the table.</p>

<p translation-result="on">而如果你自己實現了資料分頁邏輯，那就要監聽該分頁器的 <code>(page)</code> 輸出，並把進行了正確的切片之後的資料發給表格。</p><p translation-origin="off">Otherwise if you are implementing the logic to paginate your data, you will want to listen to the
paginator's <code>(page)</code> output and pass the right slice of data to your table.</p>

<p translation-result="on">要了解使用和設定 <code>&lt;mat-paginator&gt;</code> 的更多訊息，參見 <a href="guide/overview">mat-paginator 的文件</a>。</p><p translation-origin="off">For more information on using and configuring the <code>&lt;mat-paginator&gt;</code>, check out the
<a href="https://material.angular.io/components/paginator/overview">mat-paginator docs</a>.</p>

<p translation-result="on"><code>MatPaginator</code> 提供了一個對錶格資料進行分頁的解決方案，不過它不是唯一的選項。
事實上，該表格可以和任何自定義的分頁器 UI 或策略類協同工作，因為 <code>MatTable</code> 及其介面並沒有綁死在任何特定的實現上。</p><p translation-origin="off">The <code>MatPaginator</code> is one provided solution to paginating your table's data, but it is not the only
option. In fact, the table can work with any custom pagination UI or strategy since the <code>MatTable</code>
and its interface is not tied to any one specific implementation.</p>

<div material-docs-example="table-pagination"></div>


        <h4 id="sorting" class="docs-header-link" translation-result="on">
          <span header-link="排序"></span>
          排序
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="sorting"></span>
          Sorting
        </h4>
      
        
      <p translation-result="on">要想為表格新增排序行為，請給它新增 <code>matSort</code> 指令並把 <code>mat-sort-header</code> 指令新增到每個允許觸發排序功能的表頭上。</p><p translation-origin="off">To add sorting behavior to the table, add the <code>matSort</code> directive to the table and add
<code>mat-sort-header</code> to each column header cell that should trigger sorting. Note that you have to import <code>MatSortModule</code> in order to initialize the <code>matSort</code> directive (see <a href="https://material.angular.io/components/sort/api">API docs</a>).</p>

<pre><code class="language-html"><span class="hljs-comment">&lt;!-- Name Column --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">ng-container</span> <span class="hljs-attr">matColumnDef</span>=<span class="hljs-string">"position"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">mat-header-cell</span> *<span class="hljs-attr">matHeaderCellDef</span> <span class="hljs-attr">mat-sort-header</span>&gt;</span> Name <span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">mat-cell</span> *<span class="hljs-attr">matCellDef</span>=<span class="hljs-string">"let element"</span>&gt;</span> {{element.position}} <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ng-container</span>&gt;</span>
</code></pre>
<p translation-result="on">如果你正在用 <code>MatTableDataSource</code> 作為資料來源，可以把 <code>MatSort</code> 提供給資料來源，這樣它就會自動監聽排序的更改，並據此修改表格中資料的排序順序。</p><p translation-origin="off">If you are using the <code>MatTableDataSource</code> for your table's data source, provide the <code>MatSort</code>
directive to the data source and it will automatically listen for sorting changes and change the
order of data rendered by the table.</p>

<p translation-result="on">預設情況下，<code>MatTableDataSource</code> 會假設已排序列的名稱和該列所顯示的屬性名是一致的。比如，下面的列定義名叫 <code>position</code>，它和要顯示在單元格中的屬性名是一樣的。</p><p translation-origin="off">By default, the <code>MatTableDataSource</code> sorts with the assumption that the sorted column's name
matches the data property name that the column displays. For example, the following column
definition is named <code>position</code>, which matches the name of the property displayed in the row cell.</p>

<p translation-result="on">注意，如果資料屬性與列名不一致，或需要更復雜的資料屬性訪問器，那麼可以設定一個自定義的 <code>sortingDataAccessor</code> 函式，以覆蓋 <code>MatTableDataSource</code> 上預設的資料訪問器。</p><p translation-origin="off">Note that if the data properties do not match the column names, or if a more complex data property
accessor is required, then a custom <code>sortingDataAccessor</code> function can be set to override the
default data accessor on the <code>MatTableDataSource</code>.</p>

<p translation-result="on">如果你沒有使用 <code>MatTableDataSource</code> 而是自己實現了資料排序邏輯，那麼可以監聽此排序器的 <code>(matSortChange)</code> 事件，並根據其排序狀態重新排序你的資料。
如果你要直接給表格提供一個陣列型資料，別忘了呼叫表格的 <code>renderRows()</code> 函式，因為它不會自動檢查對陣列的修改。</p><p translation-origin="off">If you are not using the <code>MatTableDataSource</code>, but instead implementing custom logic to sort your
data, listen to the sort's <code>(matSortChange)</code> event and re-order your data according to the sort state.
If you are providing a data array directly to the table, don't forget to call <code>renderRows()</code> on the
table, since it will not automatically check the array for changes.</p>

<div material-docs-example="table-sorting"></div>

<p translation-result="on">要了解使用和設定排序行為的更多訊息，參見 <a href="guide/overview">matSort 的文件</a>。</p><p translation-origin="off">For more information on using and configuring the sorting behavior, check out the
<a href="https://material.angular.io/components/sort/overview">matSort docs</a>.</p>

<p translation-result="on"><code>MatSort</code> 是用來排序表格資料的一個現成的解決方案，但它不是唯一的選擇。
事實上，表格可以和任何一個自定義的排序 UI 或策略類協同工作，因為 <code>MatTable</code> 及其介面沒有綁死到任何一個特定的實現。</p><p translation-origin="off">The <code>MatSort</code> is one provided solution to sorting your table's data, but it is not the only option.
In fact, the table can work with any custom sorting UI or strategy since the <code>MatTable</code> and
its interface is not tied to any one specific implementation.</p>


        <h4 id="filtering" class="docs-header-link" translation-result="on">
          <span header-link="過濾"></span>
          過濾
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="filtering"></span>
          Filtering
        </h4>
      
        
      <p translation-result="on">Angular Material 沒有提供用於過濾 <code>MatTable</code> 的具體元件，因為沒有一種簡單通用的方式可以為表格資料新增過濾介面。</p><p translation-origin="off">Angular Material does not provide a specific component to be used for filtering the <code>MatTable</code>
since there is no single common approach to adding a filter UI to table data.</p>

<p translation-result="on">通常的策略是新增一個輸入框，使用者可以在其中輸入過濾字串，並監聽此輸入，以修改從資料來源提供給表格的資料。</p><p translation-origin="off">A general strategy is to add an input where users can type in a filter string and listen to this
input to change what data is offered from the data source to the table.</p>

<p translation-result="on">如果你正在使用 <code>MatTableDataSource</code> 只要將過濾字串提供給 <code>MatTableDataSource</code> 就可以了。
資料來源將會把每一行資料進行縮減，並根據本行有沒有包含該過濾字串進行篩選。
預設情況下，行數據的縮減函式會把傳給它的物件的所有值都連線起來，並轉換成小寫。</p><p translation-origin="off">If you are using the <code>MatTableDataSource</code>, simply provide the filter string to the
<code>MatTableDataSource</code>. The data source will reduce each row data to a serialized form and will filter
out the row if it does not contain the filter string. By default, the row data reducing function
will concatenate all the object values and convert them to lowercase.</p>

<p translation-result="on">比如，資料 <code>{id: 123, name: 'Mr. Smith', favoriteColor: 'blue'}</code> 將會縮減成 <code>123mr. smithblue</code>。
如果你的過濾字串是 <code>blue</code>，那麼它就是對應的，因為它包含在縮減後的字串中，這一行就會顯示在表格中。</p><p translation-origin="off">For example, the data object <code>{id: 123, name: 'Mr. Smith', favoriteColor: 'blue'}</code> will be reduced
to <code>123mr. smithblue</code>. If your filter string was <code>blue</code> then it would be considered a match because
it is contained in the reduced string, and the row would be displayed in the table.</p>

<p translation-result="on">要覆蓋這種預設的過濾行為，可以設定一個自定義的 <code>filterPredicate</code> 函式，它可以接受一個資料物件和過濾器字串，如果認為該資料物件是對應的，就回傳 <code>true</code>。</p><p translation-origin="off">To override the default filtering behavior, a custom <code>filterPredicate</code> function can be set which
takes a data object and filter string and returns true if the data object is considered a match.</p>

<p translation-result="on">如果你想在過濾器對應不上資料時顯示某種訊息，可以使用 <code>*matNoDataRow</code> 指令。</p><p translation-origin="off">If you want to show a message when not data matches the filter, you can use the <code>*matNoDataRow</code>
directive.</p>

<!--- example(table-filtering) -->


        <h4 id="selection" class="docs-header-link" translation-result="on">
          <span header-link="選取"></span>
          選取
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="selection"></span>
          Selection
        </h4>
      
        
      <p translation-result="on">目前，還沒有對給表格新增選取介面提供正式的支援。不過 Angular Material 提供了一些元件和程式碼片段來支援它。
下面這些步驟是為表格新增列選擇功能的解決方案之一（但不是唯一的）。</p><p translation-origin="off">Right now there is no formal support for adding a selection UI to the table, but Angular Material
does offer the right components and pieces to set this up. The following steps are one solution but
it is not the only way to incorporate row selection in your table.</p>


        <h5 id="1-add-a-selection-model" class="docs-header-link" translation-result="on">
          <span header-link="1-新增選取模式"></span>
          1. 新增選取模式
        </h5><h5 class="docs-header-link" translation-origin="off">
          <span header-link="1-add-a-selection-model"></span>
          1. Add a selection model
        </h5>
      
        
      <p translation-result="on">首先建立來自 <code>@angular/cdk/collections</code> 的 <code>SelectionModel</code>，它用來維護選取狀態。</p><p translation-origin="off">Get started by setting up a <code>SelectionModel</code> from <code>@angular/cdk/collections</code> that will maintain the
selection state.</p>

<pre><code class="language-js"><span class="hljs-keyword">const</span> initialSelection = [];
<span class="hljs-keyword">const</span> allowMultiSelect = <span class="hljs-literal">true</span>;
<span class="hljs-built_in">this</span>.selection = <span class="hljs-keyword">new</span> SelectionModel&lt;MyDataType&gt;(allowMultiSelect, initialSelection);
</code></pre>

        <h5 id="2-define-a-selection-column" class="docs-header-link" translation-result="on">
          <span header-link="2-定義選擇列"></span>
          2. 定義選擇列
        </h5><h5 class="docs-header-link" translation-origin="off">
          <span header-link="2-define-a-selection-column"></span>
          2. Define a selection column
        </h5>
      
        
      <p translation-result="on">新增一個列定義，以顯示本行的檢查框，包括給標題行的主控檢查框。
其列名也要新增到提供給表頭和數據行的待顯示列數組中。</p><p translation-origin="off">Add a column definition for displaying the row checkboxes, including a main toggle checkbox for
the header. The column name should be added to the list of displayed columns provided to the
header and data row.</p>

<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">ng-container</span> <span class="hljs-attr">matColumnDef</span>=<span class="hljs-string">"select"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">mat-header-cell</span> *<span class="hljs-attr">matHeaderCellDef</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mat-checkbox</span> (<span class="hljs-attr">change</span>)=<span class="hljs-string">"$event ? toggleAllRows() : null"</span>
                  [<span class="hljs-attr">checked</span>]=<span class="hljs-string">"selection.hasValue() &amp;&amp; isAllSelected()"</span>
                  [<span class="hljs-attr">indeterminate</span>]=<span class="hljs-string">"selection.hasValue() &amp;&amp; !isAllSelected()"</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">mat-checkbox</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">mat-cell</span> *<span class="hljs-attr">matCellDef</span>=<span class="hljs-string">"let row"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mat-checkbox</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"$event.stopPropagation()"</span>
                  (<span class="hljs-attr">change</span>)=<span class="hljs-string">"$event ? selection.toggle(row) : null"</span>
                  [<span class="hljs-attr">checked</span>]=<span class="hljs-string">"selection.isSelected(row)"</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">mat-checkbox</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ng-container</span>&gt;</span>
</code></pre>

        <h5 id="3-add-event-handling-logic" class="docs-header-link" translation-result="on">
          <span header-link="3-新增事件處理邏輯"></span>
          3. 新增事件處理邏輯
        </h5><h5 class="docs-header-link" translation-origin="off">
          <span header-link="3-add-event-handling-logic"></span>
          3. Add event handling logic
        </h5>
      
        
      <p translation-result="on">在元件邏輯中實現一些行為，以處理表頭的主控開關，並檢查是否所有的行都被選中了。</p><p translation-origin="off">Implement the behavior in your component's logic to handle the header's main toggle and checking
if all rows are selected.</p>

<pre><code class="language-js"><span class="hljs-comment">/** Whether the number of selected elements matches the total number of rows. */</span>
<span class="hljs-function"><span class="hljs-title">isAllSelected</span>(<span class="hljs-params"></span>)</span> {
  <span class="hljs-keyword">const</span> numSelected = <span class="hljs-built_in">this</span>.selection.selected.length;
  <span class="hljs-keyword">const</span> numRows = <span class="hljs-built_in">this</span>.dataSource.data.length;
  <span class="hljs-keyword">return</span> numSelected == numRows;
}

<span class="hljs-comment">/** Selects all rows if they are not all selected; otherwise clear selection. */</span>
<span class="hljs-function"><span class="hljs-title">toggleAllRows</span>(<span class="hljs-params"></span>)</span> {
  <span class="hljs-built_in">this</span>.isAllSelected() ?
      <span class="hljs-built_in">this</span>.selection.clear() :
      <span class="hljs-built_in">this</span>.dataSource.data.forEach(<span class="hljs-function"><span class="hljs-params">row</span> =&gt;</span> <span class="hljs-built_in">this</span>.selection.select(row));
}
</code></pre>

        <h5 id="4-include-overflow-styling" class="docs-header-link" translation-result="on">
          <span header-link="4-包含-overflow-樣式"></span>
          4. 包含 overflow 樣式
        </h5><h5 class="docs-header-link" translation-origin="off">
          <span header-link="4-include-overflow-styling"></span>
          4. Include overflow styling
        </h5>
      
        
      <p translation-result="on">最後，調整選取列的樣式，讓它的 overflow 不是 hidden。這樣就可以讓漣漪效果延伸到單元格之外。</p><p translation-origin="off">Finally, adjust the styling for the select column so that its overflow is not hidden. This allows
the ripple effect to extend beyond the cell.</p>

<pre><code class="language-css"><span class="hljs-selector-class">.mat-column-select</span> {
  <span class="hljs-attribute">overflow</span>: initial;
}
</code></pre>
<!--- example(table-selection) -->


        <h4 id="footer-row" class="docs-header-link" translation-result="on">
          <span header-link="表尾"></span>
          表尾
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="footer-row"></span>
          Footer row
        </h4>
      
        
      <p translation-result="on">新增一個表尾的定義併為其指定一個單元格樣板，可以為表格新增一個表尾。表尾會顯示在所有資料行之後。</p><p translation-origin="off">A footer row can be added to the table by adding a footer row definition to the table and adding
footer cell templates to column definitions. The footer row will be rendered after the rendered
data rows.</p>

<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">ng-container</span> <span class="hljs-attr">matColumnDef</span>=<span class="hljs-string">"cost"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">mat-header-cell</span> *<span class="hljs-attr">matHeaderCellDef</span>&gt;</span> Cost <span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">mat-cell</span> *<span class="hljs-attr">matCellDef</span>=<span class="hljs-string">"let data"</span>&gt;</span> {{data.cost}} <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">mat-footer-cell</span> *<span class="hljs-attr">matFooterCellDef</span>&gt;</span> {{totalCost}} <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ng-container</span>&gt;</span>

...

<span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">mat-header-row</span> *<span class="hljs-attr">matHeaderRowDef</span>=<span class="hljs-string">"columnsToDisplay"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">mat-row</span> *<span class="hljs-attr">matRowDef</span>=<span class="hljs-string">"let myRowData; columns: columnsToDisplay"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">mat-footer-row</span> *<span class="hljs-attr">matFooterRowDef</span>=<span class="hljs-string">"columnsToDisplay"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
</code></pre>
<!--- example(table-footer-row) -->


        <h4 id="sticky-rows-and-columns" class="docs-header-link" translation-result="on">
          <span header-link="釘住某些行和列"></span>
          釘住某些行和列
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="sticky-rows-and-columns"></span>
          Sticky Rows and Columns
        </h4>
      
        
      <p translation-result="on">透過使用 <code>position: sticky</code> 樣式，可以固定住表格的某些行和列，這樣它們在捲動時就不會離開視野。
表格所提供的輸入屬性將會自動應用正確的 CSS 樣式，以便這些行和列能被釘住。</p><p translation-origin="off">By using <code>position: sticky</code> styling, the table's rows and columns can be fixed so that they do not
leave the viewport even when scrolled. The table provides inputs that will automatically apply the
correct CSS styling so that the rows and columns become sticky.</p>

<p translation-result="on">要想把表頭行固定到包含此表格的視野頂部，你可以給 <code>matHeaderRowDef</code> 新增輸入屬性 <code>sticky</code>。</p><p translation-origin="off">In order to fix the header row to the top of the scrolling viewport containing the table, you can
add a <code>sticky</code> input to the <code>matHeaderRowDef</code>.</p>

<!--- example(table-sticky-header) -->

<p translation-result="on">同樣的，我們也可以釘住表格的表尾。注意，如果你正在使用原生的 <code>&lt;table&gt;</code> 和 Safari，那麼只有當所有的尾行都帶有 <code>sticky</code> 的時候，表尾才會被釘住。</p><p translation-origin="off">Similarly, this can also be applied to the table's footer row. Note that if you are using the native
<code>&lt;table&gt;</code> and using Safari, then the footer will only stick if <code>sticky</code> is applied to all the
rendered footer rows.</p>

<!--- example(table-sticky-footer) -->

<p translation-result="on">還可以把一些列的單元格固定在水平捲動檢視的頭部和尾部，只要把 <code>sticky</code> 或 <code>stickyEnd</code> 指令新增到 <code>ng-container</code> 的列定義上就可以了。</p><p translation-origin="off">It is also possible to fix cell columns to the start or end of the horizontally scrolling viewport.
To do this, add the <code>sticky</code> or <code>stickyEnd</code> directive to the <code>ng-container</code> column definition.</p>

<!--- example(table-sticky-columns) -->

<p translation-result="on">該屬性受到 Chrome、Firefox、Safari 和 Edge 的支援。IE 不支援它，但它會優雅的失敗，其後果只是那些列沒有釘住而已。</p><p translation-origin="off">This feature is supported by Chrome, Firefox, Safari, and Edge. It is not supported in IE, but
it does fail gracefully so that the rows simply do not stick.</p>

<p translation-result="on">注意，在移動版的 Safari 上，如果使用 Flex 佈局的表格，當捲動時，釘在多於一個方向的單元格將難以保持在正確的位置上。
比如，如果表頭釘在頂部，而且第一列也釘住了，那麼當捲動時，其左上角的單元格將會不斷抖動。</p><p translation-origin="off">Note that on Safari mobile when using the flex-based table, a cell stuck in more than one direction
will struggle to stay in the correct position as you scroll. For example, if a header row is stuck
to the top and the first column is stuck, then the top-left-most cell will appear jittery as you
scroll.</p>

<p translation-result="on">此外，在一些特殊情況下，Edge 中的定位也會不穩定。比如，如果捲動容器具有複雜的陰影而且還有兄弟元素，那麼釘住的單元格就會抖動。
這裡是 <a href="https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/17514118/">Edge 上關於此問題的 Issue</a>。</p><p translation-origin="off">Also, sticky positioning in Edge will appear shaky for special cases. For example, if the scrolling
container has a complex box shadow and has sibling elements, the stuck cells will appear jittery.
There is currently an <a href="https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/17514118/">open issue with Edge</a>
to resolve this.</p>


        <h4 id="multiple-row-templates" class="docs-header-link" translation-result="on">
          <span header-link="多行樣板"></span>
          多行樣板
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="multiple-row-templates"></span>
          Multiple row templates
        </h4>
      
        
      <p translation-result="on">當使用 <code>multiTemplateDataRows</code> 指令以支援讓每個資料物件對應多行時，<code>*matRowDef</code> 中使用同一個上下文，不過其 <code>index</code> 值要換成 <code>dataIndex</code> 和 <code>renderIndex</code>。</p><p translation-origin="off">When using the <code>multiTemplateDataRows</code> directive to support multiple rows for each data object, the context of <code>*matRowDef</code> is the same except that the <code>index</code> value is replaced by <code>dataIndex</code> and <code>renderIndex</code>.</p>


        <h3 id="accessibility" class="docs-header-link" translation-result="on">
          <span header-link="無障礙性"></span>
          無障礙性
        </h3><h3 class="docs-header-link" translation-origin="off">
          <span header-link="accessibility"></span>
          Accessibility
        </h3>
      
        
      <p translation-result="on">預設情況下， <code>MatTable</code> 會應用 <code>role="table"</code>，這裡假設表格主要包含靜態內容。你可以透過在 table 元素上顯式設定 <code>role="grid"</code> 或 <code>role="treegrid"</code> 來更改其角色。雖然更改角色會更新子元素角色，例如將 <code>role="cell"</code> 更改為 <code>role="gridcell"</code> ，但這<em>不會</em>對錶格應用額外的鍵盤輸入處理或焦點管理邏輯。</p><p translation-origin="off">By default, <code>MatTable</code> applies <code>role="table"</code>, assuming the table's contains primarily static
content. You can change the role by explicitly setting <code>role="grid"</code> or <code>role="treegrid"</code> on the
table element. While changing the role will update child element roles, such as changing
<code>role="cell"</code> to <code>role="gridcell"</code>, this does <em>not</em> apply additional keyboard input handling or
focus management to the table.</p>

<p translation-result="on">始終透過表格元素上的 <code>aria-label</code> 或 <code>aria-labelledby</code> 為你的表格提供無障礙標籤。</p><p translation-origin="off">Always provide an accessible label for your tables via <code>aria-label</code> or <code>aria-labelledby</code> on the
table element.</p>


        <h3 id="tables-with-display-flex" class="docs-header-link" translation-result="on">
          <span header-link="使用-display-flex-的表格"></span>
          使用 <code>display: flex</code> 的表格
        </h3><h3 class="docs-header-link" translation-origin="off">
          <span header-link="tables-with-display-flex"></span>
          Tables with <code>display: flex</code>
        </h3>
      
        
      <p translation-result="on"><code>MatTable</code> 不要求你使用原生 HTML 表格，所以你可以用另一種基於 <code>display: flex</code> 的方式來控制表格的樣式。</p><p translation-origin="off">The <code>MatTable</code> does not require that you use a native HTML table. Instead, you can use an
alternative approach that uses <code>display: flex</code> for the table's styles.</p>

<p translation-result="on">這種方式把原生的 <code>table</code> 元素標記替換成 <code>MatTable</code> 指令的選擇器。
比如 <code>&lt;table mat-table&gt;</code> 變成了 <code>&lt;mat-table&gt;</code>；<code>&lt;tr mat-row&gt;</code> 變成了 <code>&lt;mat-row&gt;</code>。下面的例子用這種方式改寫了以前的例子：</p><p translation-origin="off">This alternative approach replaces the native table element tags with the <code>MatTable</code> directive
selectors. For example, <code>&lt;table mat-table&gt;</code> becomes <code>&lt;mat-table&gt;</code>; <code>&lt;tr mat-row&gt;</code> becomes
<code>&lt;mat-row&gt;</code>. The following shows a previous example using this alternative template:</p>

<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">mat-table</span> [<span class="hljs-attr">dataSource</span>]=<span class="hljs-string">"dataSource"</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- User name Definition --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">ng-container</span> <span class="hljs-attr">matColumnDef</span>=<span class="hljs-string">"username"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mat-header-cell</span> *<span class="hljs-attr">matHeaderCellDef</span>&gt;</span> User name <span class="hljs-tag">&lt;/<span class="hljs-name">mat-header-cell</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mat-cell</span> *<span class="hljs-attr">matCellDef</span>=<span class="hljs-string">"let row"</span>&gt;</span> {{row.username}} <span class="hljs-tag">&lt;/<span class="hljs-name">mat-cell</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">ng-container</span>&gt;</span>

  <span class="hljs-comment">&lt;!-- Age Definition --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">ng-container</span> <span class="hljs-attr">matColumnDef</span>=<span class="hljs-string">"age"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mat-header-cell</span> *<span class="hljs-attr">matHeaderCellDef</span>&gt;</span> Age <span class="hljs-tag">&lt;/<span class="hljs-name">mat-header-cell</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mat-cell</span> *<span class="hljs-attr">matCellDef</span>=<span class="hljs-string">"let row"</span>&gt;</span> {{row.age}} <span class="hljs-tag">&lt;/<span class="hljs-name">mat-cell</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">ng-container</span>&gt;</span>

  <span class="hljs-comment">&lt;!-- Title Definition --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">ng-container</span> <span class="hljs-attr">matColumnDef</span>=<span class="hljs-string">"title"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mat-header-cell</span> *<span class="hljs-attr">matHeaderCellDef</span>&gt;</span> Title <span class="hljs-tag">&lt;/<span class="hljs-name">mat-header-cell</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mat-cell</span> *<span class="hljs-attr">matCellDef</span>=<span class="hljs-string">"let row"</span>&gt;</span> {{row.title}} <span class="hljs-tag">&lt;/<span class="hljs-name">mat-cell</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">ng-container</span>&gt;</span>

  <span class="hljs-comment">&lt;!-- Header and Row Declarations --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">mat-header-row</span> *<span class="hljs-attr">matHeaderRowDef</span>=<span class="hljs-string">"['username', 'age', 'title']"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mat-header-row</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">mat-row</span> *<span class="hljs-attr">matRowDef</span>=<span class="hljs-string">"let row; columns: ['username', 'age', 'title']"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mat-row</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mat-table</span>&gt;</span>
</code></pre>
<p translation-result="on">注意，這種方法意味著你不能使用某些原生表格的專屬屬性，比如 colspan/rowspan 或一些能根據其內容自動調整自身大小的列。</p><p translation-origin="off">Note that this approach means you cannot include certain native-table features such colspan/rowspan
or have columns that resize themselves based on their content.</p>


        <h3 id="tables-with-matripple" class="docs-header-link" translation-result="on">
          <span header-link="帶有-matripple-的表格"></span>
          帶有 <code>MatRipple</code> 的表格
        </h3><h3 class="docs-header-link" translation-origin="off">
          <span header-link="tables-with-matripple"></span>
          Tables with <code>MatRipple</code>
        </h3>
      
        
      <p translation-result="on">預設情況下， <code>MatTable</code> 不會為行設定 Material Design 漣漪。可以使用來自 <code>@angular/material/core</code> 的 <code>MatRipple</code> 指令將漣漪效果新增到錶行。由於瀏覽器的限制，漣漪不能應用於原生 <code>th</code> 或 <code>tr</code> 元素。設定漣漪的推薦方法是使用 <code>MatTable</code> 的非原生 <code>display: flex</code> 變體。</p><p translation-origin="off">By default, <code>MatTable</code> does not set up Material Design ripples for rows. A ripple effect can be
added to table rows by using the <code>MatRipple</code> directive from <code>@angular/material/core</code>. Due to
limitations in browsers, ripples cannot be applied native <code>th</code> or <code>tr</code> elements. The recommended
approach for setting up ripples is using the non-native <code>display: flex</code> variant of <code>MatTable</code>.</p>

<!--- example(table-with-ripples) -->

<p translation-result="on">有關原生錶行上的漣漪及其限制的更多詳細訊息，請參見<a href="https://github.com/angular/components/issues/11883#issuecomment-634942981">本錯誤</a>。</p><p translation-origin="off">More details about ripples on native table rows and their limitations can be found <a href="https://github.com/angular/components/issues/11883#issuecomment-634942981">in this issue</a>.</p>

</div>