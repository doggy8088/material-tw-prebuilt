<div class="docs-markdown"><p translation-result="on"><code>mat-tree</code> 提供了一個 Material Design 風格的樹，它可用於顯示層次型資料。</p><p translation-origin="off">The <code>mat-tree</code> provides a Material Design styled tree that can be used to display hierarchy
data.</p>

<p translation-result="on">樹控制元件基於 CDK 的樹控制元件建立，並使用相似的介面來表示其資料來源和樣板。只是它們的元素和屬性選擇器會用 <code>mat-</code> 字首，而不是 <code>cdk-</code> 字首。</p><p translation-origin="off">This tree builds on the foundation of the CDK tree and uses a similar interface for its
data source input and template, except that its element and attribute selectors will be prefixed
with <code>mat-</code> instead of <code>cdk-</code>.</p>

<p translation-result="on">有兩種型別的樹：扁平樹和巢狀樹。這兩種樹的 DOM 結構是不同的。</p><p translation-origin="off">There are two types of trees: Flat tree and nested tree. The DOM structures are different for these
two types of trees. Flat trees generally offer better performance, while nested trees provide
flexibility.</p>


        <h4 id="flat-tree" class="docs-header-link" translation-result="on">
          <span header-link="扁平樹"></span>
          扁平樹
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="flat-tree"></span>
          Flat tree
        </h4>
      
        
      <p translation-result="on">在扁平樹中，其層次是扁平的，各個節點不會渲染在其它節點內部，而是渲染成一系列兄弟節點。
<code>TreeFlattener</code> 的實例用來根據層次型資料生成扁平的條目清單。
每個節點的級別都是從其 <code>TreeControl</code> 中的 <code>getLevel</code> 方法中讀取的；這個級別可用來設定節點樣式，使其縮排到適當的級別。</p><p translation-origin="off">In a flat tree, the hierarchy is flattened; nodes are not rendered inside of each other,
but instead are rendered as siblings in sequence. An instance of <code>TreeFlattener</code> is
used to generate the flat list of items from hierarchical data. The "level" of each tree
node is read through the <code>getLevel</code> method of the <code>TreeControl</code>; this level can be
used to style the node such that it is indented to the appropriate level.</p>

<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">mat-tree</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">mat-tree-node</span>&gt;</span> parent node <span class="hljs-tag">&lt;/<span class="hljs-name">mat-tree-node</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">mat-tree-node</span>&gt;</span> -- child node1 <span class="hljs-tag">&lt;/<span class="hljs-name">mat-tree-node</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">mat-tree-node</span>&gt;</span> -- child node2 <span class="hljs-tag">&lt;/<span class="hljs-name">mat-tree-node</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mat-tree</span>&gt;</span>
</code></pre>
<div material-docs-example="tree-flat-overview"></div>

<p translation-result="on">扁平樹通常更容易設定樣式和審查元素。它們對各種捲動更加友好 —— 比如無盡捲動或虛擬捲動。</p><p translation-origin="off">Flat trees are generally easier to style and inspect. They are also more friendly to scrolling
variations, such as infinite or virtual scrolling. Flat trees
generally offer better performance.</p>

<!--TODO(tinayuangao): Add a flat tree example here -->


        <h4 id="nested-tree" class="docs-header-link" translation-result="on">
          <span header-link="巢狀樹"></span>
          巢狀樹
        </h4><h4 class="docs-header-link" translation-origin="off">
          <span header-link="nested-tree"></span>
          Nested tree
        </h4>
      
        
      <p translation-result="on">在巢狀樹中，子節點會放在其父節點 DOM 元素的內部。父節點有一個出口（outlet），用來存放其所有子節點。</p><p translation-origin="off">In Nested tree, children nodes are placed inside their parent node in DOM. The parent node has an
outlet to keep all the children nodes.</p>

<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">mat-tree</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">mat-nested-tree-node</span>&gt;</span>
     parent node
     <span class="hljs-tag">&lt;<span class="hljs-name">mat-nested-tree-node</span>&gt;</span> -- child node1 <span class="hljs-tag">&lt;/<span class="hljs-name">mat-nested-tree-node</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">mat-nested-tree-node</span>&gt;</span> -- child node2 <span class="hljs-tag">&lt;/<span class="hljs-name">mat-nested-tree-node</span>&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">mat-nested-tree-node</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mat-tree</span>&gt;</span>
</code></pre>
<div material-docs-example="tree-nested-overview"></div>

<p translation-result="on">當以扁平節點的形式難以視覺化地表示層次關係時，使用巢狀樹會更容易。</p><p translation-origin="off">Nested trees are easier to work with when hierarchical relationships are visually
represented in ways that would be difficult to accomplish with flat nodes.</p>

<!--TODO(tinayuangao): Add a nested tree example here -->


        <h3 id="features" class="docs-header-link" translation-result="on">
          <span header-link="屬性"></span>
          屬性
        </h3><h3 class="docs-header-link" translation-origin="off">
          <span header-link="features"></span>
          Features
        </h3>
      
        
      <p translation-result="on"><code>&lt;mat-tree&gt;</code> 本身只關心樹形結構的渲染工作。透過在節點樣板內新增行為（比如襯距 <code>padding</code> 和切換 <code>toggle</code>），可以在標準樹的基礎上建立額外功能。
那些能影響渲染資料的互動（比如展開/摺疊）應該能透過表格的資料來源進行傳播。</p><p translation-origin="off">The <code>&lt;mat-tree&gt;</code> itself only deals with the rendering of a tree structure.
Additional features can be built on top of the tree by adding behavior inside node templates
(e.g., padding and toggle). Interactions that affect the
rendered data (such as expand/collapse) should be propagated through the table's data source.</p>


        <h3 id="treecontrol" class="docs-header-link" translation-result="on">
          <span header-link="樹控制器"></span>
          樹控制器
        </h3><h3 class="docs-header-link" translation-origin="off">
          <span header-link="treecontrol"></span>
          TreeControl
        </h3>
      
        
      <p translation-result="on"><code>TreeControl</code> 控制樹節點的展開/摺疊狀態。使用者可以透過數控件來遞迴的展開/摺疊樹節點。
對於巢狀樹的節點，要把一個 <code>getChildren</code> 函式傳給 <code>NestedTreeControl</code>，來讓它能遞迴使用。
<code>getChildren</code> 函式可以回傳一個指定節點上子節點的 <code>Observable</code> 或其子節點的陣列。
對於扁平樹的節點，要把 <code>getLevel</code> 和 <code>isExpandable</code> 函式傳給 <code>FlatTreeControl</code>，來讓它能遞迴使用。</p><p translation-origin="off">The <code>TreeControl</code> controls the expand/collapse state of tree nodes. Users can expand/collapse a tree
node recursively through tree control. For nested tree node, <code>getChildren</code> function need to pass to
the <code>NestedTreeControl</code> to make it work recursively. The <code>getChildren</code> function may return an 
observable of children for a given node, or an array of children. 
For flattened tree node, <code>getLevel</code> and <code>isExpandable</code> functions need to pass to the 
<code>FlatTreeControl</code> to make it work recursively.</p>


        <h3 id="toggle" class="docs-header-link" translation-result="on">
          <span header-link="開關"></span>
          開關
        </h3><h3 class="docs-header-link" translation-origin="off">
          <span header-link="toggle"></span>
          Toggle
        </h3>
      
        
      <p translation-result="on">可以把 <code>matTreeNodeToggle</code> 新增到樹節點樣板中，以展開/摺疊樹節點。此開關可以切換 <code>TreeControl</code> 中的展開/摺疊函式，還能把 <code>[matTreeNodeToggleRecursive]</code> 設定為 <code>true</code> 來遞迴展開/摺疊樹節點。</p><p translation-origin="off">A <code>matTreeNodeToggle</code> can be added in the tree node template to expand/collapse the tree node. The
toggle toggles the expand/collapse functions in <code>TreeControl</code> and is able to expand/collapse a
tree node recursively by setting <code>[matTreeNodeToggleRecursive]</code> to <code>true</code>.</p>

<p translation-result="on">此開關可以放在樹節點中的任何地方，並且只能透過點選（<code>click</code>）操作進行切換。</p><p translation-origin="off">The toggle can be placed anywhere in the tree node, and is only toggled by <code>click</code> action.</p>


        <h3 id="padding-flat-tree-only" class="docs-header-link" translation-result="on">
          <span header-link="襯距（只對扁平樹）"></span>
          襯距（只對扁平樹）
        </h3><h3 class="docs-header-link" translation-origin="off">
          <span header-link="padding-flat-tree-only"></span>
          Padding (Flat tree only)
        </h3>
      
        
      <p translation-result="on"><code>matTreeNodePadding</code> 可以放在扁平樹的節點樣板中，以展示扁平樹節點的 <code>level</code> 訊息。</p><p translation-origin="off">The <code>matTreeNodePadding</code> can be placed in a flat tree's node template to display the <code>level</code>
information of a flat tree node.</p>

<p translation-result="on">巢狀樹不需要進行襯距，因為 DOM 中的層次結構就能很容易地加上它。</p><p translation-origin="off">Nested tree does not need this padding since padding can be easily added to the hierarchy
structure in DOM.</p>


        <h3 id="accessibility" class="docs-header-link" translation-result="on">
          <span header-link="無障礙性"></span>
          無障礙性
        </h3><h3 class="docs-header-link" translation-origin="off">
          <span header-link="accessibility"></span>
          Accessibility
        </h3>
      
        
      <p translation-result="on">沒有文字或標籤的樹應該透過 <code>aria-label</code> 或 <code>aria-labelledby</code> 給出一個有意義的標籤。如果沒有指定，則 <code>aria-readonly</code> 會預設為 <code>true</code>。</p><p translation-origin="off">Trees without text or labels should be given a meaningful label via <code>aria-label</code> or
<code>aria-labelledby</code>. The <code>aria-readonly</code> defaults to <code>true</code> if it's not set.</p>

<p translation-result="on">樹的角色是 <code>tree</code>。
父節點會帶有 <code>role="group"</code>，而葉節點會帶有 <code>role="treeitem"</code>。</p><p translation-origin="off">Tree's role is <code>tree</code>.
Parent nodes are given <code>role="group"</code>, while leaf nodes are given <code>role="treeitem"</code></p>

<p translation-result="on"><code>mat-tree</code> 不會自行管理任何焦點/鍵盤互動。
開發者可以根據需求為應用自行新增焦點/鍵盤互動。</p><p translation-origin="off"><code>mat-tree</code> does not manage any focus/keyboard interaction on its own. Users can add desired
focus/keyboard interactions in their application.</p>

</div>